<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebShark - Network Packet Visualizer</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a202c;
            color: #e2e8f0;
            min-height: 100vh;
        }

        .header {
            background: #2d3748;
            padding: 1rem;
            text-align: center;
            color: #edf2f7;
            border-bottom: 1px solid #4a5568;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .card {
            background: #2d3748;
            border-radius: 15px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid #4a5568;
        }

        .card h3 {
            color: #4a5568;
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid #e2e8f0;
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .packet-log {
            grid-column: 1 / -1;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 1.5rem;
        }

        .packet-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: #1f2937;
            border-radius: 8px;
            border-left: 4px solid #4299e1;
            animation: slideIn 0.3s ease-out;
        }

        .packet-item:nth-child(even) {
            background: #27303f;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .packet-info {
            display: flex;
            flex-direction: column;
            flex: 1;
        }

        .packet-main {
            font-weight: 600;
            color: #edf2f7;
        }

        .packet-detail {
            font-size: 0.85rem;
            color: #a0aec0;
        }

        .packet-protocol {
            background: #4299e1;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .tcp-session {
            margin-bottom: 1rem;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background: #f7fafc;
        }

        .session-header {
            padding: 1rem;
            background: #edf2f7;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            transition: background-color 0.2s ease;
        }

        .session-header:hover {
            background: #e2e8f0;
        }

        .session-info {
            display: flex;
            flex-direction: column;
        }

        .session-title {
            font-weight: 600;
            color: #2d3748;
            font-size: 1rem;
        }

        .session-subtitle {
            font-size: 0.85rem;
            color: #718096;
            margin-top: 0.25rem;
        }

        .session-toggle {
            font-size: 1.2rem;
            color: #4a5568;
            transition: transform 0.2s ease;
        }

        .session-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .session-packets {
            padding: 0 1rem 1rem 1rem;
        }

        .session-packets.collapsed {
            display: none;
        }

        .session-packet {
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            background: white;
            border-radius: 4px;
            border-left: 3px solid #4299e1;
            font-size: 0.85rem;
        }

        .session-stats {
            display: flex;
            gap: 1rem;
            font-size: 0.75rem;
            color: #718096;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #48bb78;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(72, 187, 120, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(72, 187, 120, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(72, 187, 120, 0);
            }
        }

        .controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .filter-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .checkbox-container input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-container label {
            cursor: pointer;
            font-weight: 500;
            color: #4a5568;
        }

        .sort-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255, 255, 255, 0.95);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .sort-controls label {
            font-weight: 500;
            color: #4a5568;
            white-space: nowrap;
        }

        .sort-controls select {
            padding: 0.5rem;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            background: white;
            color: #4a5568;
            cursor: pointer;
        }

        .advanced-controls {
            grid-column: 1 / -1;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 1rem;
        }

        .control-row {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: #f7fafc;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .control-group label {
            font-weight: 500;
            color: #4a5568;
            white-space: nowrap;
        }

        .control-group input, .control-group select {
            padding: 0.5rem;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            background: white;
            color: #4a5568;
        }

        .filter-input {
            width: 300px;
            font-family: monospace;
        }

        .memory-info {
            font-size: 0.85rem;
            color: #718096;
            margin-left: 0.5rem;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            background: #4299e1;
            color: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: #3182ce;
            transform: translateY(-2px);
        }

        .btn.danger {
            background: #e53e3e;
        }

        .btn.danger:hover {
            background: #c53030;
        }

        .tabs {
            display: flex;
            gap: 1rem;
            justify-content: center;
            background: #2d3748;
            padding: 0.5rem 0;
        }

        .tab-btn {
            background: #4a5568;
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            cursor: pointer;
            border-radius: 4px;
        }

        .tab-btn.active {
            background: #4299e1;
        }

        .view {
            display: none;
        }

        .view.active {
            display: block;
        }

        #vizView .viz-container {
            display: flex;
            flex-direction: column;
            gap: 2rem;
            align-items: center;
        }

        #timeChart {
            width: 100%;
            max-width: 800px;
            margin: 0 auto 2rem;
        }

        #totalTrafficChart {
            width: 100%;
            max-width: 800px;
            margin: 0 auto 2rem;
        }

        #chordDiagram {
            display: block;
            margin: 0 auto;
        }

        /* ⚡ ULTRAfast loading skeleton */
        .loading-skeleton {
            animation: skeleton-loading 1.5s infinite;
        }
        
        .skeleton-line {
            height: 16px;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            border-radius: 4px;
            margin-bottom: 8px;
            animation: skeleton-shimmer 1.5s infinite;
        }
        
        @keyframes skeleton-shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        
        .ultra-fast-expand {
            transition: max-height 0.15s ease-out;
        }
        
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }

            .container {
                padding: 1rem;
            }

            #vizView .viz-container {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🦈 WebShark</h1>
        <p>Real-time Network Traffic Monitoring</p>
    </div>

    <div class="tabs">
        <button class="tab-btn active" id="topTab">トップビュー</button>
        <button class="tab-btn" id="vizTab">可視化ビュー</button>
    </div>

    <div id="topView" class="view active">
    <div class="container">
        <div class="controls">
            <button class="btn" id="startBtn">Start</button>
            <button class="btn danger" id="stopBtn">Stop</button>
            <button class="btn" id="clearBtn">Clear Log</button>
            
            <div class="filter-controls">
                <div class="checkbox-container">
                    <input type="checkbox" id="hideLocalhost" checked>
                    <label for="hideLocalhost">Hide localhost traffic</label>
                </div>
            </div>
            
            <div class="sort-controls">
                <label for="sortSessions">Sort by:</label>
                <select id="sortSessions">
                    <option value="recent">Most Recent</option>
                    <option value="traffic">Traffic Volume</option>
                    <option value="alphabetical">Alphabetical</option>
                </select>
            </div>
        </div>

        <div class="status">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Waiting...</span>
            <span id="memoryStatus" class="memory-info">Memory: 0MB</span>
        </div>

        <div class="advanced-controls">
            <h3>🔧 Advanced Settings</h3>
            <div class="control-row">
                <div class="control-group">
                    <label for="memoryLimit">Memory Limit:</label>
                    <input type="number" id="memoryLimit" value="50" min="10" max="500" step="10">
                    <span>MB</span>
                </div>
                
                <div class="control-group">
                    <label for="maxSessions">Max Sessions:</label>
                    <input type="number" id="maxSessions" value="20" min="5" max="100" step="5">
                </div>
                
                <div class="control-group">
                    <label for="maxPacketsPerSession">Max Packets per Session:</label>
                    <input type="number" id="maxPacketsPerSession" value="50" min="10" max="200" step="10">
                </div>

                <div class="control-group">
                    <input type="checkbox" id="groupLanWan" checked>
                    <label for="groupLanWan">Group by LAN/WAN</label>
                </div>
            </div>
            
            <div class="control-row">
                <div class="control-group">
                    <label for="tsharkFilter">tshark Filter:</label>
                    <input type="text" id="tsharkFilter" class="filter-input" placeholder="e.g. tcp port 80 or udp port 53">
                    <button class="btn" id="applyFilterBtn">Apply</button>
                </div>
            </div>
        </div>

        <div class="dashboard">
            <div class="card">
                <h3>📊 Statistics</h3>
                <div class="stat-item">
                    <span>Total Packets:</span>
                    <span id="totalPackets">0</span>
                </div>
                <div class="stat-item">
                    <span>Connection:</span>
                    <span id="connectionStatus">Disconnected</span>
                </div>
            </div>

            <div class="card">
                <h3>🔗 By Protocol</h3>
                <div id="protocolStats">
                    <div class="stat-item">
                        <span>No data</span>
                        <span>-</span>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>📍 Top Sources</h3>
                <div id="sourceStats">
                    <div class="stat-item">
                        <span>No data</span>
                        <span>-</span>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>🎯 Top Destinations</h3>
                <div id="destStats">
                    <div class="stat-item">
                        <span>No data</span>
                        <span>-</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="card packet-log">
            <h3>📡 Smart Communication Flows</h3>
            <div id="flowList"></div>
        </div>
    </div>
    </div>

        <div id="vizView" class="view">
        <div class="container viz-container">
            <svg id="chordDiagram" width="800" height="800"></svg>
            <canvas id="timeChart" height="300"></canvas>
            <canvas id="totalTrafficChart" height="300"></canvas>
        </div>
    </div>

    <!-- pako.js for decompression -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        let ws = null;
        let isRunning = false;
        let packetCount = 0;
        let PROTOCOLS = [];
        let LOCAL_IPS = [];
        // Simple grouping
        let smartGroups = {
            tcp_sessions: new Map(),
            udp_flows: new Map(),
            other_protocols: new Map()
        };
        let groupMetadata = new Map(); // group metadata
        let estimatedMemoryUsage = 0; // estimated memory usage (MB)
        let batchUpdateTimer = null; // batch update timer
        let pendingUpdates = false; // pending update flag
        let packetQueue = []; // packet processing queue
        let isProcessingQueue = false; // queue processing flag
        let cachedElements = new Map(); // DOM element cache
        let shouldSort = false; // whether sorting is needed

        const topTab = document.getElementById('topTab');
        const vizTab = document.getElementById('vizTab');
        const topView = document.getElementById('topView');
        const vizView = document.getElementById('vizView');

        // Chart.js time series
        const timeCtx = document.getElementById('timeChart').getContext('2d');
        const timeChart = new Chart(timeCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Bytes per second',
                    data: [],
                    borderColor: '#4299e1',
                    backgroundColor: 'rgba(66,153,225,0.3)',
                    fill: true,
                    tension: 0.1
                }]
            },
            options: {
                animation: false,
                scales: { x: { display: true }, y: { beginAtZero: true } }
            }
        });

        const trafficSeries = new Map();
        let totalTraffic = 0;

        const totalCtx = document.getElementById('totalTrafficChart').getContext('2d');
        const totalChart = new Chart(totalCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Total Bytes',
                    data: [],
                    borderColor: '#68d391',
                    backgroundColor: 'rgba(104,211,145,0.3)',
                    fill: true,
                    tension: 0.1
                }]
            },
            options: {
                animation: false,
                scales: { x: { display: true }, y: { beginAtZero: true } }
            }
        });

        // D3 chord diagram data
        const chordSvg = d3.select('#chordDiagram');
        const hostIndex = new Map();
        let hosts = [];
        let matrix = [];

        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const clearBtn = document.getElementById('clearBtn');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const totalPacketsEl = document.getElementById('totalPackets');
        const connectionStatusEl = document.getElementById('connectionStatus');
        const flowList = document.getElementById('flowList');
        const memoryStatusEl = document.getElementById('memoryStatus');
        const applyFilterBtn = document.getElementById('applyFilterBtn');
        const groupLanWanCheckbox = document.getElementById('groupLanWan');

        topTab.addEventListener('click', () => {
            topTab.classList.add('active');
            vizTab.classList.remove('active');
            topView.classList.add('active');
            vizView.classList.remove('active');
        });

        vizTab.addEventListener('click', () => {
            vizTab.classList.add('active');
            topTab.classList.remove('active');
            vizView.classList.add('active');
            topView.classList.remove('active');
        });

        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            ws = new WebSocket(wsUrl);

            ws.onopen = function() {
                console.log('WebSocket connection established');
                connectionStatusEl.textContent = 'Connected';
                statusText.textContent = 'Capturing packets...';
                statusDot.style.background = '#48bb78';
                isRunning = true;
            };

            ws.onmessage = async function(event) {
                let packets = [];

                if (typeof event.data === 'string') {
                    const msg = JSON.parse(event.data);
                    if (msg.type === 'ctx') {
                        PROTOCOLS = msg.protocols;
                        LOCAL_IPS = msg.local_ips || [];
                        return;
                    }
                    packets = [msg];
                } else if (event.data instanceof Blob) {
                    // Decompress data
                    try {
                        const arrayBuffer = await event.data.arrayBuffer();
                        const decompressed = pako.inflate(new Uint8Array(arrayBuffer), { to: 'string' });
                        packets = JSON.parse(decompressed);
                    } catch (e) {
                        console.error('Failed to decompress data:', e);
                        return;
                    }
                }
                
                // Add batch packets to queue
                packets.forEach(packet => {
                    if (packet.proto !== undefined && PROTOCOLS.length) {
                        packet.protocol = PROTOCOLS[packet.proto] || 'UNKNOWN';
                    }
                    if (packet.sub_proto === null) packet.sub_proto = undefined;
                    packetQueue.push(packet);
                    packetCount++;
                });
                
                totalPacketsEl.textContent = packetCount.toLocaleString();
                
                // Start queue processing
                if (!isProcessingQueue) {
                    requestAnimationFrame(processPacketQueue);
                }
            };

            ws.onclose = function() {
                console.log('WebSocket connection closed');
                connectionStatusEl.textContent = 'Disconnected';
                statusText.textContent = 'Waiting...';
                statusDot.style.background = '#e53e3e';
                isRunning = false;
            };

            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
                connectionStatusEl.textContent = 'Error';
                statusDot.style.background = '#ed8936';
            };
        }

        function isLocalhostTraffic(packet) {
            const localhostAddresses = ['127.0.0.1', '::1', 'localhost'];
            return localhostAddresses.includes(packet.src_ip) || 
                   localhostAddresses.includes(packet.dst_ip) ||
                   (packet.src_ip === packet.dst_ip && 
                    (packet.src_ip.startsWith('127.') || packet.src_ip.startsWith('::1')));
        }

        // 🚀 Simple protocol classification
        function classifyPacket(packet) {
            const protocol = packet.protocol.toUpperCase();
            const info = createSessionInfo(packet);

            let type = 'other_protocols';
            if (protocol === 'TCP') type = 'tcp_sessions';
            else if (protocol === 'UDP') type = 'udp_flows';

            return { type, key: info.key, direction: info.direction, a: info.a, b: info.b };
        }

        function isLan(ip) {
            return LOCAL_IPS.includes(ip) ||
                   ip.startsWith('10.') ||
                   ip.startsWith('192.168.') ||
                   (/^172\.(1[6-9]|2\d|3[01])\./.test(ip));
        }

        function getDisplayLabel(ip) {
            return isLan(ip) ? `LAN_${ip}` : `WAN_${ip}`;
        }

        function getDisplayKey(packet) {
            const portMatch = packet.info.match(/(\d+)\s*→\s*(\d+)/);
            let src = getDisplayLabel(packet.src_ip);
            let dst = getDisplayLabel(packet.dst_ip);
            if (portMatch) {
                src = `${src}:${portMatch[1]}`;
                dst = `${dst}:${portMatch[2]}`;
            }
            return `${src} ⇄ ${dst}`;
        }

        // create session key and direction
        function createSessionInfo(packet) {
            const portMatch = packet.info.match(/(\d+)\s*→\s*(\d+)/);
            let src = packet.src_ip;
            let dst = packet.dst_ip;
            if (groupLanWanCheckbox && groupLanWanCheckbox.checked) {
                src = isLan(packet.src_ip) ? 'LAN' : 'WAN';
                dst = isLan(packet.dst_ip) ? 'LAN' : 'WAN';
            }
            if (portMatch) {
                src = `${src}:${portMatch[1]}`;
                dst = `${dst}:${portMatch[2]}`;
            }
            let a = src;
            let b = dst;
            let direction = 'a_to_b';
            if (a < b) {
                direction = 'a_to_b';
            } else if (a > b) {
                direction = 'b_to_a';
                const tmp = a; a = b; b = tmp;
            } else {
                direction = 'a_to_b';
            }
            return { key: `${a} ⇄ ${b}`, direction, a, b };
        }

        // ⚡ ULTRA fast flow element creation
        function createFlowElement(groupType, groupKey, firstPacket) {
            const flowDiv = document.createElement('div');
            flowDiv.className = 'tcp-session'; // reuse CSS
            flowDiv.id = `flow-${groupType}-${groupKey.replace(/[^a-zA-Z0-9]/g, '-')}`;
            
            const { icon, title, subtitle } = getFlowDisplayInfo(groupType, groupKey, firstPacket);
            const timestamp = new Date(firstPacket.timestamp * 1000).toLocaleTimeString();
            
            flowDiv.innerHTML = `
                <div class="session-header" onclick="toggleFlowUltraFast('${flowDiv.id}')">
                    <div class="session-info">
                        <div class="session-title">${icon} ${title}</div>
                        <div class="session-subtitle">
                            <span class="session-stats">
                                <span>Started: ${timestamp}</span>
                                <span>Packets: <span id="${flowDiv.id}-count">1</span></span>
                                <span>Sent: <span id="${flowDiv.id}-sent">0B</span></span>
                                <span>Received: <span id="${flowDiv.id}-recv">0B</span></span>
                                <span>${subtitle}</span>
                            </span>
                        </div>
                    </div>
                    <div class="session-toggle collapsed" id="${flowDiv.id}-toggle">▶</div>
                </div>
                <div class="session-packets collapsed" id="${flowDiv.id}-packets">
                    <div class="loading-skeleton" style="display: none;">
                        <div class="skeleton-line"></div>
                        <div class="skeleton-line"></div>
                        <div class="skeleton-line"></div>
                    </div>
                </div>
            `;
            
            return flowDiv;
        }
        
        function getFlowDisplayInfo(groupType, groupKey, packet) {
            const title = (groupLanWanCheckbox && groupLanWanCheckbox.checked)
                ? getDisplayKey(packet)
                : groupKey;
            switch (groupType) {
                case 'tcp_sessions':
                    const tcpSubtitle = packet.sub_proto ? `${packet.sub_proto} over TCP` : 'TCP Session';
                    return {
                        icon: '🔐',
                        title: title,
                        subtitle: tcpSubtitle
                    };
                case 'udp_flows':
                    const udpSubtitle = packet.sub_proto ? `${packet.sub_proto} over UDP` : 'UDP Flow';
                    return {
                        icon: '📦',
                        title: title,
                        subtitle: udpSubtitle
                    };
                default:
                    return {
                        icon: '❓',
                        title: title,
                        subtitle: `${packet.protocol}Protocol`
                    };
            }
        }

        function processPacketQueue() {
            if (packetQueue.length === 0) {
                isProcessingQueue = false;
                return;
            }
            
            isProcessingQueue = true;
            const startTime = performance.now();
            const maxProcessingTime = 8; // process up to 8ms
            
            while (packetQueue.length > 0 && (performance.now() - startTime) < maxProcessingTime) {
                const packet = packetQueue.shift();
                processPacket(packet);
            }
            
            if (packetQueue.length > 0) {
                // if packets remain continue next frame
                requestAnimationFrame(processPacketQueue);
            } else {
                isProcessingQueue = false;
                // perform sort here if needed
                if (shouldSort) {
                    shouldSort = false;
                    sortFlows(); // call correct function
                }
            }
        }

        function processPacket(packet) {
            // localhost filtering
            const hideLocalhost = getCachedElement('hideLocalhost').checked;
            if (hideLocalhost && isLocalhostTraffic(packet)) {
                return; // skip localhost traffic
            }
            addPacketToFlow(packet); // new smart flow handling
            updateVisualization(packet);
        }

        // 🚀 ULTRA smart packet processing
        function addPacketToFlow(packet) {
            const classification = classifyPacket(packet);
            const { type, key, direction, a, b } = classification;
            
            let flowElement = smartGroups[type].get(key);
            
            if (!flowElement) {
                // create new flow
                flowElement = createFlowElement(type, key, packet);
                smartGroups[type].set(key, flowElement);
                
                // initialize metadata
                const metadata = {
                    type: type,
                    key: key,
                    packetCount: 0,
                    packets: [],
                    firstSeen: packet.timestamp,
                    lastSeen: packet.timestamp,
                    packetsContainer: flowElement.querySelector('.session-packets'),
                    countElement: flowElement.querySelector(`#${flowElement.id}-count`),
                    sentElement: flowElement.querySelector(`#${flowElement.id}-sent`),
                    recvElement: flowElement.querySelector(`#${flowElement.id}-recv`),
                    endpointA: a,
                    endpointB: b,
                    sentBytes: 0,
                    recvBytes: 0,
                    isExpanded: false
                };
                
                groupMetadata.set(`${type}-${key}`, metadata);
                flowList.insertBefore(flowElement, flowList.firstChild);
                shouldSort = true;
            }
            
            const metadata = groupMetadata.get(`${type}-${key}`);
            metadata.packets.push(packet);
            metadata.packetCount++;
            metadata.lastSeen = packet.timestamp;
            metadata.countElement.textContent = metadata.packetCount;
            if (direction === 'a_to_b') {
                metadata.sentBytes += packet.length;
                metadata.sentElement.textContent = formatBytes(metadata.sentBytes);
            } else {
                metadata.recvBytes += packet.length;
                metadata.recvElement.textContent = formatBytes(metadata.recvBytes);
            }
            
            if (metadata.isExpanded) {
                addPacketToExpandedFlow(metadata, packet);
            }
            
            estimatedMemoryUsage += 0.001;
            checkLimits();
        }
        
        function addPacketToExpandedFlow(metadata, packet) {
            const packetsContainer = metadata.packetsContainer;
            const skeleton = packetsContainer.querySelector('.loading-skeleton');
            if (skeleton) skeleton.style.display = 'none';
            
            const packetDiv = document.createElement('div');
            packetDiv.className = 'session-packet';
            
            const timestamp = formatTimestamp(packet.timestamp);
            const protoLabel = packet.sub_proto ? `${packet.protocol} (${packet.sub_proto})` : packet.protocol;
            packetDiv.innerHTML = `
                <div><strong>${getDisplayLabel(packet.src_ip)} → ${getDisplayLabel(packet.dst_ip)}</strong></div>
                <div>${timestamp} | ${packet.length} bytes | ${protoLabel}</div>
                <div style="color: #718096; margin-top: 0.25rem;">${packet.info}</div>
            `;
            
            packetsContainer.insertBefore(packetDiv, packetsContainer.firstChild);
            
            // packet limit
            const maxPacketsPerSession = parseInt(getCachedElement('maxPacketsPerSession').value) || 50;
            while (packetsContainer.children.length > maxPacketsPerSession + 1) { // +1 for skeleton
                packetsContainer.removeChild(packetsContainer.lastChild);
            }
        }

        // ⚡ ULTRA fast flow toggle (display within 0.1s)
        function toggleFlowUltraFast(flowId) {
            const packetsContainer = document.getElementById(`${flowId}-packets`);
            const toggleIcon = document.getElementById(`${flowId}-toggle`);
            const skeleton = packetsContainer.querySelector('.loading-skeleton');
            
            if (packetsContainer.classList.contains('collapsed')) {
                // ✨ instant skeleton display (0.01s)
                packetsContainer.classList.remove('collapsed');
                toggleIcon.classList.remove('collapsed');
                toggleIcon.textContent = '▼';
                
                if (skeleton) skeleton.style.display = 'block';
                
                // get metadata
                const metadataKey = flowId.replace('flow-', '').replace(/-/g, '-', 1);
                const metadata = Array.from(groupMetadata.values()).find(m => 
                    flowId.includes(m.type) && flowId.includes(m.key.replace(/[^a-zA-Z0-9]/g, '-'))
                );
                
                if (metadata) {
                    metadata.isExpanded = true;
                    // load packets asynchronously
                    requestIdleCallback(() => loadPacketsChunked(metadata));
                }
                
            } else {
                packetsContainer.classList.add('collapsed');
                toggleIcon.classList.add('collapsed');
                toggleIcon.textContent = '▶';
                
                // update metadata
                const metadataKey = flowId.replace('flow-', '').replace(/-/g, '-', 1);
                const metadata = Array.from(groupMetadata.values()).find(m => 
                    flowId.includes(m.type) && flowId.includes(m.key.replace(/[^a-zA-Z0-9]/g, '-'))
                );
                
                if (metadata) {
                    metadata.isExpanded = false;
                }
            }
        }
        
        // 🚀 chunked ultra-fast loading
        function loadPacketsChunked(metadata) {
            const packetsContainer = metadata.packetsContainer;
            const skeleton = packetsContainer.querySelector('.loading-skeleton');
            const packets = metadata.packets;
            
            if (packets.length === 0) {
                if (skeleton) skeleton.style.display = 'none';
                return;
            }
            
            const chunkSize = 20; // load 20 items at a time
            let currentIndex = 0;
            
            function loadChunk() {
                const endIndex = Math.min(currentIndex + chunkSize, packets.length);
                const fragment = document.createDocumentFragment();
                
                for (let i = currentIndex; i < endIndex; i++) {
                    const packet = packets[packets.length - 1 - i]; // newest first
                    const packetDiv = document.createElement('div');
                    packetDiv.className = 'session-packet';

                    const timestamp = formatTimestamp(packet.timestamp);
                    const protoLabel = packet.sub_proto ? `${packet.protocol} (${packet.sub_proto})` : packet.protocol;
                    packetDiv.innerHTML = `
                        <div><strong>${getDisplayLabel(packet.src_ip)} → ${getDisplayLabel(packet.dst_ip)}</strong></div>
                        <div>${timestamp} | ${packet.length} bytes | ${protoLabel}</div>
                        <div style="color: #718096; margin-top: 0.25rem;">${packet.info}</div>
                    `;
                    
                    fragment.appendChild(packetDiv);
                }
                
                if (skeleton && skeleton.parentNode) {
                    packetsContainer.insertBefore(fragment, skeleton);
                } else {
                    packetsContainer.appendChild(fragment);
                }
                
                currentIndex = endIndex;
                
                if (currentIndex < packets.length && metadata.isExpanded) {
                    // load next chunk asynchronously
                    requestAnimationFrame(loadChunk);
                } else {
                    // loading complete
                    if (skeleton) skeleton.style.display = 'none';
                }
            }
            
            // load first chunk immediately
            loadChunk();
        }

        function refreshSessionPackets(sessionId) {
            // if necessaryredraw session packets
            // omitted for performance reasons
        }

        function getCachedElement(id) {
            if (!cachedElements.has(id)) {
                cachedElements.set(id, document.getElementById(id));
            }
            return cachedElements.get(id);
        }
        
        function formatTimestamp(timestamp) {
            return new Date(timestamp * 1000).toLocaleTimeString();
        }

        function formatBytes(bytes) {
            if (bytes < 1024) return `${bytes}B`;
            if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)}KB`;
            return `${(bytes / (1024*1024)).toFixed(1)}MB`;
        }
        
        function checkLimits() {
            const maxSessions = parseInt(getCachedElement('maxSessions').value) || 20;
            const memoryLimit = parseInt(getCachedElement('memoryLimit').value) || 50;

            if (estimatedMemoryUsage > memoryLimit) {
                cleanupOldFlows();
            }

            const totalFlows = groupMetadata.size;
            if (totalFlows > maxSessions) {
                const oldestFlow = flowList.lastChild;
                if (oldestFlow) {
                    const oldestKey = Array.from(groupMetadata.keys()).find(key => {
                        const metadata = groupMetadata.get(key);
                        return metadata && smartGroups[metadata.type].get &&
                               smartGroups[metadata.type].get(metadata.key) === oldestFlow;
                    });
                    if (oldestKey) {
                        removeFlow(oldestKey);
                    }
                }
            }

            updateMemoryDisplay();
        }

        function scheduleBatchUpdate() {
            if (pendingUpdates) return;
            
            pendingUpdates = true;
            if (batchUpdateTimer) {
                clearTimeout(batchUpdateTimer);
            }
            
            batchUpdateTimer = setTimeout(() => {
                performBatchUpdate();
                pendingUpdates = false;
            }, 500); // extended to 500ms
        }
        
        function performBatchUpdate() {
            updateMemoryDisplay();
            if (shouldSort) {
                shouldSort = false;
                sortFlows();
            }
        }

        function sortFlows() {
            const sortOption = getCachedElement('sortSessions').value;
            const allFlows = [];
            
            // collect flows from all groups
            Object.keys(smartGroups).forEach(groupType => {
                const group = smartGroups[groupType];
                for (const [key, element] of group.entries()) {
                    allFlows.push({ key: `${groupType}-${key}`, element });
                }
            });
            
            allFlows.sort((a, b) => {
                const metaA = groupMetadata.get(a.key);
                const metaB = groupMetadata.get(b.key);
                
                if (!metaA || !metaB) return 0;
                
                switch (sortOption) {
                    case 'traffic':
                        const bytesA = (metaA.sentBytes || 0) + (metaA.recvBytes || 0);
                        const bytesB = (metaB.sentBytes || 0) + (metaB.recvBytes || 0);
                        return bytesB - bytesA;
                    case 'alphabetical':
                        return a.key.localeCompare(b.key);
                    case 'recent':
                    default:
                        return metaB.lastSeen - metaA.lastSeen;
                }
            });
            
            const fragment = document.createDocumentFragment();
            allFlows.forEach(({ element }) => {
                if (element && element.parentNode) {
                    fragment.appendChild(element);
                }
            });
            flowList.appendChild(fragment);
        }

        function estimatePacketMemoryUsage(packet) {
            // approx memory usage per packet (MB)
            const baseSize = 0.001; // around 1KB
            const infoSize = packet.info.length * 0.000001; // dependent on text length
            return baseSize + infoSize;
        }

        function updateMemoryDisplay() {
            memoryStatusEl.textContent = `Memory: ${estimatedMemoryUsage.toFixed(1)}MB`;
            
            // warn when memory usage near limit
            const memoryLimit = parseInt(document.getElementById('memoryLimit').value) || 50;
            if (estimatedMemoryUsage > memoryLimit * 0.8) {
                memoryStatusEl.style.color = '#e53e3e';
            } else if (estimatedMemoryUsage > memoryLimit * 0.6) {
                memoryStatusEl.style.color = '#ed8936';
            } else {
                memoryStatusEl.style.color = '#718096';
            }
        }

        function removeFlow(metadataKey) {
            const metadata = groupMetadata.get(metadataKey);
            if (!metadata) return;
            
            const { type, key } = metadata;
            const flowElement = smartGroups[type].get(key);
            
            if (flowElement && flowElement.parentNode) {
                // approximate memory usage decrease
                estimatedMemoryUsage -= metadata.packetCount * 0.001;
                
                smartGroups[type].delete(key);
                flowList.removeChild(flowElement);
                groupMetadata.delete(metadataKey);
                rebuildHostMatrix();
            }
        }

        function cleanupOldFlows() {
            // remove oldest flows
            const flows = Array.from(groupMetadata.entries())
                .sort(([,a], [,b]) => a.lastSeen - b.lastSeen); // oldest first
            
            const memoryLimit = parseInt(getCachedElement('memoryLimit').value) || 50;
            
            while (estimatedMemoryUsage > memoryLimit * 0.7 && flows.length > 0) {
                const [oldestKey] = flows.shift();
                removeFlow(oldestKey);
            }
        }

        function rebuildHostMatrix() {
            hostIndex.clear();
            hosts = [];
            matrix = [];

            const maxSessions = parseInt(getCachedElement('maxSessions').value) || 20;

            const hostBytes = new Map();
            groupMetadata.forEach(meta => {
                const bytes = (meta.sentBytes || 0) + (meta.recvBytes || 0);
                hostBytes.set(meta.endpointA, (hostBytes.get(meta.endpointA) || 0) + bytes);
                hostBytes.set(meta.endpointB, (hostBytes.get(meta.endpointB) || 0) + bytes);
            });

            const sortedHosts = Array.from(hostBytes.entries())
                .sort(([,a], [,b]) => b - a)
                .slice(0, maxSessions)
                .map(([h]) => h);

            sortedHosts.forEach((h, idx) => {
                hostIndex.set(h, idx);
                hosts.push(h);
            });

            matrix = Array.from({length: hosts.length}, () => new Array(hosts.length).fill(0));

            groupMetadata.forEach(meta => {
                const i = hostIndex.get(meta.endpointA);
                const j = hostIndex.get(meta.endpointB);
                if (i === undefined || j === undefined) return;

                const bytes = (meta.sentBytes || 0) + (meta.recvBytes || 0);
                matrix[i][j] += bytes;
                matrix[j][i] += bytes;
            });
        }

        async function applyTsharkFilter() {
            const filterValue = document.getElementById('tsharkFilter').value.trim();
            
            try {
                const response = await fetch('/api/filter', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        tshark_filter: filterValue || null
                    })
                });
                
                if (response.ok) {
                    console.log('Filter applied:', filterValue);
                    // Clearing flows and restarting with new filter
                    flowList.innerHTML = '';
                    Object.keys(smartGroups).forEach(groupType => {
                        smartGroups[groupType].clear();
                    });
                    groupMetadata.clear();
                    packetQueue.length = 0;
                    estimatedMemoryUsage = 0;
                    rebuildHostMatrix();
                    updateMemoryDisplay();
                } else {
                    console.error('Failed to apply filter');
                }
            } catch (error) {
                console.error('Filter error:', error);
            }
        }

        function addPacketToLog(packet) {
            // localhost filtering
            const hideLocalhost = document.getElementById('hideLocalhost').checked;
            if (hideLocalhost && isLocalhostTraffic(packet)) {
                return; // skip localhost traffic
            }

            const packetDiv = document.createElement('div');
            packetDiv.className = 'packet-item';
            
            const timestamp = new Date(packet.timestamp * 1000).toLocaleTimeString();
            
            const protoLabel = packet.sub_proto ? `${packet.protocol} (${packet.sub_proto})` : packet.protocol;
            packetDiv.innerHTML = `
                <div class="packet-info">
                    <div class="packet-main">${getDisplayLabel(packet.src_ip)} → ${getDisplayLabel(packet.dst_ip)}</div>
                    <div class="packet-detail">${timestamp} | ${packet.length} bytes | ${packet.info}</div>
                </div>
                <div class="packet-protocol">${protoLabel}</div>
            `;

            packetList.insertBefore(packetDiv, packetList.firstChild);

            // keep up to 100 packet logs
            while (packetList.children.length > 100) {
                packetList.removeChild(packetList.lastChild);
            }
        }

        async function updateStats() {
            try {
                const response = await fetch('/api/stats');
                const stats = await response.json();
                
                console.log('Fetched statistics:', stats);
                
                updateProtocolStats(stats.protocols);
                updateTopStats('sourceStats', stats.top_sources);
                updateTopStats('destStats', stats.top_destinations);
            } catch (error) {
                console.error('Failed to fetch statistics:', error);
            }
        }

        function updateProtocolStats(protocols) {
            const container = getCachedElement('protocolStats');
            if (!container) {
                console.error('protocolStats element not found');
                return;
            }
            
            container.innerHTML = '';
            
            console.log('Protocol stats updated:', protocols);
            
            const sorted = Object.entries(protocols)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 5);
            
            if (sorted.length === 0) {
                container.innerHTML = '<div class="stat-item"><span>No data</span><span>-</span></div>';
                return;
            }
            
            sorted.forEach(([protocol, count]) => {
                const item = document.createElement('div');
                item.className = 'stat-item';
                item.innerHTML = `<span>${protocol.toUpperCase()}</span><span>${count}</span>`;
                container.appendChild(item);
            });
        }

        function updateTopStats(containerId, data) {
            const container = getCachedElement(containerId);
            if (!container) {
                console.error(`${containerId} element not found`);
                return;
            }
            
            container.innerHTML = '';
            
            const sorted = Object.entries(data)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 5);
            
            if (sorted.length === 0) {
                container.innerHTML = '<div class="stat-item"><span>No data</span><span>-</span></div>';
                return;
            }
            
            sorted.forEach(([ip, count]) => {
                const item = document.createElement('div');
                item.className = 'stat-item';
                item.innerHTML = `<span>${ip}</span><span>${count}</span>`;
                container.appendChild(item);
            });
        }

        function updateVisualization(packet) {
            // update time series
            const sec = Math.floor(packet.timestamp);
            trafficSeries.set(sec, (trafficSeries.get(sec) || 0) + packet.length);
            totalTraffic += packet.length;

            updateChordTraffic(packet.src_ip, packet.dst_ip, packet.length);
        }

        function refreshTimeChart() {
            const now = Math.floor(Date.now() / 1000);
            const windowSize = 60;
            const labels = [];
            const data = [];
            for (let i = windowSize - 1; i >= 0; i--) {
                const t = now - i;
                labels.push(new Date(t * 1000).toLocaleTimeString());
                data.push(trafficSeries.get(t) || 0);
            }
            timeChart.data.labels = labels;
            timeChart.data.datasets[0].data = data;
            timeChart.update('none');
        }

        function refreshTotalTrafficChart() {
            const now = Math.floor(Date.now() / 1000);
            const windowSize = 60;
            const labels = [];
            const data = [];
            let runningTotal = totalTraffic;
            for (let i = now; i > now - windowSize; i--) {
                labels.unshift(new Date(i * 1000).toLocaleTimeString());
                data.unshift(runningTotal);
                runningTotal -= trafficSeries.get(i) || 0;
            }
            totalChart.data.labels = labels;
            totalChart.data.datasets[0].data = data;
            totalChart.update('none');
        }

        function updateChordTraffic(src, dst, bytes) {
            let i = hostIndex.get(src);
            if (i === undefined) {
                i = hosts.length;
                hostIndex.set(src, i);
                hosts.push(src);
                matrix.forEach(row => row.push(0));
                matrix.push(new Array(hosts.length).fill(0));
            }
            let j = hostIndex.get(dst);
            if (j === undefined) {
                j = hosts.length;
                hostIndex.set(dst, j);
                hosts.push(dst);
                matrix.forEach(row => row.push(0));
                matrix.push(new Array(hosts.length).fill(0));
            }
            matrix[i][j] += bytes;
            matrix[j][i] += bytes;
        }

        function drawChordDiagram() {
            const width = 800;
            const height = 800;
            const margin = 100;
            const outerRadius = Math.min(width, height) / 2 - 40;
            const innerRadius = outerRadius - 20;

            const chord = d3.chord().padAngle(0.05)(matrix);
            const arc = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius);
            const link = d3.linkRadial().angle(d => d.angle).radius(innerRadius);
            const color = d3.scaleOrdinal(d3.schemeCategory10);

            chordSvg.attr('viewBox', [-(width / 2 + margin), -(height / 2 + margin), width + margin * 2, height + margin * 2]);
            chordSvg.selectAll('*').remove();

            const g = chordSvg.append('g');

            const groups = g.append('g')
                .selectAll('g')
                .data(chord.groups)
                .join('g');

            groups.append('path')
                .attr('fill', d => color(d.index))
                .attr('d', arc);

            groups.append('text')
                .attr('dy', -3)
                .attr('fill', '#fff')
                .attr('transform', d => {
                    const angle = (d.startAngle + d.endAngle) / 2;
                    const rotate = angle * 180 / Math.PI - 90;
                    const flip = angle > Math.PI ? ' rotate(180)' : '';
                    const translate = outerRadius + 10;
                    return `rotate(${rotate}) translate(${translate})${flip}`;
                })
                .attr('text-anchor', d => ((d.startAngle + d.endAngle) / 2) > Math.PI ? 'end' : 'start')
                .text(d => hosts[d.index]);

            g.append('g')
                .attr('fill', 'none')
                .selectAll('path')
                .data(chord)
                .join('path')
                .attr('stroke', '#888')
                .attr('stroke-width', 1.5)
                .attr('d', d => link({
                    source: { angle: (d.source.startAngle + d.source.endAngle) / 2, radius: innerRadius },
                    target: { angle: (d.target.startAngle + d.target.endAngle) / 2, radius: innerRadius }
                }));
        }

        setInterval(() => {
            refreshTimeChart();
            refreshTotalTrafficChart();
            drawChordDiagram();
        }, 1000);

        startBtn.addEventListener('click', function() {
            if (!isRunning) {
                connectWebSocket();
            }
        });

        stopBtn.addEventListener('click', function() {
            if (ws && isRunning) {
                ws.close();
            }
        });

        clearBtn.addEventListener('click', function() {
            flowList.innerHTML = '';
            // clear all smart groups
            Object.keys(smartGroups).forEach(groupType => {
                smartGroups[groupType].clear();
            });
            groupMetadata.clear();
            packetQueue.length = 0; // clear queue too
            packetCount = 0;
            estimatedMemoryUsage = 0;
            totalPacketsEl.textContent = '0';
            rebuildHostMatrix();
            updateMemoryDisplay();
        });

        // sort feature event listener
        getCachedElement('sortSessions').addEventListener('change', function() {
            sortFlows(); // sort immediately
        });

        // reset flows when LAN/WAN grouping changes
        groupLanWanCheckbox.addEventListener('change', function() {
            clearBtn.click();
        });

        // filter apply button listener
        applyFilterBtn.addEventListener('click', applyTsharkFilter);

        // apply filter on Enter key
        document.getElementById('tsharkFilter').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                applyTsharkFilter();
            }
        });

        // update statistics periodically
        setInterval(updateStats, 5000); // back to 5 seconds
        
        // regular memory display update
        setInterval(updateMemoryDisplay, 2000);
        
        // fetch initial statistics
        updateStats();

        // initial connection
        connectWebSocket();
    </script>
</body>
</html>