<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebShark - Network Packet Visualizer</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a202c;
            color: #e2e8f0;
            min-height: 100vh;
        }

        .header {
            background: #2d3748;
            padding: 1rem;
            text-align: center;
            color: #edf2f7;
            border-bottom: 1px solid #4a5568;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .card {
            background: #2d3748;
            border-radius: 15px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid #4a5568;
        }

        .card h3 {
            color: #4a5568;
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid #e2e8f0;
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .packet-log {
            grid-column: 1 / -1;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 1.5rem;
        }

        .packet-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: #1f2937;
            border-radius: 8px;
            border-left: 4px solid #4299e1;
            animation: slideIn 0.3s ease-out;
        }

        .packet-item:nth-child(even) {
            background: #27303f;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .packet-info {
            display: flex;
            flex-direction: column;
            flex: 1;
        }

        .packet-main {
            font-weight: 600;
            color: #edf2f7;
        }

        .packet-detail {
            font-size: 0.85rem;
            color: #a0aec0;
        }

        .packet-protocol {
            background: #4299e1;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .tcp-session {
            margin-bottom: 1rem;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background: #f7fafc;
        }

        .session-header {
            padding: 1rem;
            background: #edf2f7;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            transition: background-color 0.2s ease;
        }

        .session-header:hover {
            background: #e2e8f0;
        }

        .session-info {
            display: flex;
            flex-direction: column;
        }

        .session-title {
            font-weight: 600;
            color: #2d3748;
            font-size: 1rem;
        }

        .session-subtitle {
            font-size: 0.85rem;
            color: #718096;
            margin-top: 0.25rem;
        }

        .session-toggle {
            font-size: 1.2rem;
            color: #4a5568;
            transition: transform 0.2s ease;
        }

        .session-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .session-packets {
            padding: 0 1rem 1rem 1rem;
        }

        .session-packets.collapsed {
            display: none;
        }

        .session-packet {
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            background: white;
            border-radius: 4px;
            border-left: 3px solid #4299e1;
            font-size: 0.85rem;
        }

        .session-stats {
            display: flex;
            gap: 1rem;
            font-size: 0.75rem;
            color: #718096;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #48bb78;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(72, 187, 120, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(72, 187, 120, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(72, 187, 120, 0);
            }
        }

        .controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .filter-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .checkbox-container input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-container label {
            cursor: pointer;
            font-weight: 500;
            color: #4a5568;
        }

        .sort-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255, 255, 255, 0.95);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .sort-controls label {
            font-weight: 500;
            color: #4a5568;
            white-space: nowrap;
        }

        .sort-controls select {
            padding: 0.5rem;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            background: white;
            color: #4a5568;
            cursor: pointer;
        }

        .advanced-controls {
            grid-column: 1 / -1;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 1rem;
        }

        .control-row {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: #f7fafc;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .control-group label {
            font-weight: 500;
            color: #4a5568;
            white-space: nowrap;
        }

        .control-group input, .control-group select {
            padding: 0.5rem;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            background: white;
            color: #4a5568;
        }

        .filter-input {
            width: 300px;
            font-family: monospace;
        }

        .memory-info {
            font-size: 0.85rem;
            color: #718096;
            margin-left: 0.5rem;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            background: #4299e1;
            color: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: #3182ce;
            transform: translateY(-2px);
        }

        .btn.danger {
            background: #e53e3e;
        }

        .btn.danger:hover {
            background: #c53030;
        }

        /* ⚡ ULTRA高速ローディングスケルトン */
        .loading-skeleton {
            animation: skeleton-loading 1.5s infinite;
        }
        
        .skeleton-line {
            height: 16px;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            border-radius: 4px;
            margin-bottom: 8px;
            animation: skeleton-shimmer 1.5s infinite;
        }
        
        @keyframes skeleton-shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        
        .ultra-fast-expand {
            transition: max-height 0.15s ease-out;
        }
        
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            .container {
                padding: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🦈 WebShark</h1>
        <p>Real-time Network Traffic Monitoring</p>
    </div>

    <div class="container">
        <div class="controls">
            <button class="btn" id="startBtn">Start</button>
            <button class="btn danger" id="stopBtn">Stop</button>
            <button class="btn" id="clearBtn">Clear Log</button>
            
            <div class="filter-controls">
                <div class="checkbox-container">
                    <input type="checkbox" id="hideLocalhost" checked>
                    <label for="hideLocalhost">Hide localhost traffic</label>
                </div>
            </div>
            
            <div class="sort-controls">
                <label for="sortSessions">Sort by:</label>
                <select id="sortSessions">
                    <option value="recent">Most Recent</option>
                    <option value="traffic">Traffic Volume</option>
                    <option value="alphabetical">Alphabetical</option>
                </select>
            </div>
        </div>

        <div class="status">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Waiting...</span>
            <span id="memoryStatus" class="memory-info">Memory: 0MB</span>
        </div>

        <div class="advanced-controls">
            <h3>🔧 Advanced Settings</h3>
            <div class="control-row">
                <div class="control-group">
                    <label for="memoryLimit">Memory Limit:</label>
                    <input type="number" id="memoryLimit" value="50" min="10" max="500" step="10">
                    <span>MB</span>
                </div>
                
                <div class="control-group">
                    <label for="maxSessions">Max Sessions:</label>
                    <input type="number" id="maxSessions" value="20" min="5" max="100" step="5">
                </div>
                
                <div class="control-group">
                    <label for="maxPacketsPerSession">Max Packets per Session:</label>
                    <input type="number" id="maxPacketsPerSession" value="50" min="10" max="200" step="10">
                </div>

                <div class="control-group">
                    <label for="netmask">Netmask:</label>
                    <select id="netmask">
                        <option value="32">/32</option>
                        <option value="24">/24</option>
                        <option value="16">/16</option>
                        <option value="8">/8</option>
                    </select>
                </div>
            </div>
            
            <div class="control-row">
                <div class="control-group">
                    <label for="tsharkFilter">tshark Filter:</label>
                    <input type="text" id="tsharkFilter" class="filter-input" placeholder="e.g. tcp port 80 or udp port 53">
                    <button class="btn" id="applyFilterBtn">Apply</button>
                </div>
            </div>
        </div>

        <div class="dashboard">
            <div class="card">
                <h3>📊 Statistics</h3>
                <div class="stat-item">
                    <span>Total Packets:</span>
                    <span id="totalPackets">0</span>
                </div>
                <div class="stat-item">
                    <span>Connection:</span>
                    <span id="connectionStatus">Disconnected</span>
                </div>
            </div>

            <div class="card">
                <h3>🔗 By Protocol</h3>
                <div id="protocolStats">
                    <div class="stat-item">
                        <span>No data</span>
                        <span>-</span>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>📍 Top Sources</h3>
                <div id="sourceStats">
                    <div class="stat-item">
                        <span>No data</span>
                        <span>-</span>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>🎯 Top Destinations</h3>
                <div id="destStats">
                    <div class="stat-item">
                        <span>No data</span>
                        <span>-</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="card packet-log">
            <h3>📡 Smart Communication Flows</h3>
            <div id="flowList"></div>
        </div>
    </div>

    <!-- pako.js for decompression -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script>
        let ws = null;
        let isRunning = false;
        let packetCount = 0;
        let PROTOCOLS = [];
        // シンプルグルーピング
        let smartGroups = {
            tcp_sessions: new Map(),
            udp_flows: new Map(),
            other_protocols: new Map()
        };
        let groupMetadata = new Map(); // グループのメタデータ
        let estimatedMemoryUsage = 0; // 推定メモリ使用量（MB）
        let batchUpdateTimer = null; // バッチ更新用タイマー
        let pendingUpdates = false; // 保留中の更新フラグ
        let packetQueue = []; // パケット処理キュー
        let isProcessingQueue = false; // キュー処理中フラグ
        let cachedElements = new Map(); // DOM要素キャッシュ
        let shouldSort = false; // ソートが必要かどうか

        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const clearBtn = document.getElementById('clearBtn');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const totalPacketsEl = document.getElementById('totalPackets');
        const connectionStatusEl = document.getElementById('connectionStatus');
        const flowList = document.getElementById('flowList');
        const memoryStatusEl = document.getElementById('memoryStatus');
        const applyFilterBtn = document.getElementById('applyFilterBtn');
        const netmaskSelect = document.getElementById('netmask');

        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            ws = new WebSocket(wsUrl);

            ws.onopen = function() {
                console.log('WebSocket接続が確立されました');
                connectionStatusEl.textContent = '接続中';
                statusText.textContent = 'パケット監視中...';
                statusDot.style.background = '#48bb78';
                isRunning = true;
            };

            ws.onmessage = async function(event) {
                let packets = [];

                if (typeof event.data === 'string') {
                    const msg = JSON.parse(event.data);
                    if (msg.type === 'ctx') {
                        PROTOCOLS = msg.protocols;
                        return;
                    }
                    packets = [msg];
                } else if (event.data instanceof Blob) {
                    // Decompress data
                    try {
                        const arrayBuffer = await event.data.arrayBuffer();
                        const decompressed = pako.inflate(new Uint8Array(arrayBuffer), { to: 'string' });
                        packets = JSON.parse(decompressed);
                    } catch (e) {
                        console.error('Failed to decompress data:', e);
                        return;
                    }
                }
                
                // Add batch packets to queue
                packets.forEach(packet => {
                    if (packet.proto !== undefined && PROTOCOLS.length) {
                        packet.protocol = PROTOCOLS[packet.proto] || 'UNKNOWN';
                    }
                    packetQueue.push(packet);
                    packetCount++;
                });
                
                totalPacketsEl.textContent = packetCount.toLocaleString();
                
                // Start queue processing
                if (!isProcessingQueue) {
                    requestAnimationFrame(processPacketQueue);
                }
            };

            ws.onclose = function() {
                console.log('WebSocket接続が終了しました');
                connectionStatusEl.textContent = '切断中';
                statusText.textContent = '待機中...';
                statusDot.style.background = '#e53e3e';
                isRunning = false;
            };

            ws.onerror = function(error) {
                console.error('WebSocketエラー:', error);
                connectionStatusEl.textContent = 'エラー';
                statusDot.style.background = '#ed8936';
            };
        }

        function isLocalhostTraffic(packet) {
            const localhostAddresses = ['127.0.0.1', '::1', 'localhost'];
            return localhostAddresses.includes(packet.src_ip) || 
                   localhostAddresses.includes(packet.dst_ip) ||
                   (packet.src_ip === packet.dst_ip && 
                    (packet.src_ip.startsWith('127.') || packet.src_ip.startsWith('::1')));
        }

        // 🚀 シンプルプロトコル分類
        function classifyPacket(packet) {
            const protocol = packet.protocol.toUpperCase();
            const info = createSessionInfo(packet);

            let type = 'other_protocols';
            if (protocol === 'TCP') type = 'tcp_sessions';
            else if (protocol === 'UDP') type = 'udp_flows';

            return { type, key: info.key, direction: info.direction, a: info.a, b: info.b };
        }

        function applyNetmask(ip, prefix) {
            const p = parseInt(prefix);
            if (p >= 32) return ip;
            const parts = ip.split('.');
            if (parts.length !== 4) return ip;
            const mask = [0,0,0,0];
            let r = p;
            for (let i=0;i<4;i++) {
                if (r >= 8) { mask[i] = 255; r -= 8; }
                else if (r > 0) { mask[i] = 256 - Math.pow(2, 8 - r); r = 0; }
            }
            const nums = parts.map(Number);
            const result = nums.map((v,i)=>v & mask[i]);
            return result.join('.') + '/' + p;
        }

        // セッションキーと向きを作成
        function createSessionInfo(packet) {
            const portMatch = packet.info.match(/(\d+)\s*→\s*(\d+)/);
            let src = packet.src_ip;
            let dst = packet.dst_ip;
            if (portMatch) {
                src = `${src}:${portMatch[1]}`;
                dst = `${dst}:${portMatch[2]}`;
            }
            const prefix = netmaskSelect ? parseInt(netmaskSelect.value) : 32;
            const srcNet = applyNetmask(packet.src_ip, prefix);
            const dstNet = applyNetmask(packet.dst_ip, prefix);
            let a = srcNet;
            let b = dstNet;
            if (portMatch) {
                a = applyNetmask(packet.src_ip, prefix) + `:${portMatch[1]}`;
                b = applyNetmask(packet.dst_ip, prefix) + `:${portMatch[2]}`;
            }
            let direction = 'a_to_b';
            if (a < b) {
                direction = 'a_to_b';
            } else if (a > b) {
                direction = 'b_to_a';
                const tmp = a; a = b; b = tmp;
            } else {
                direction = 'a_to_b';
            }
            return { key: `${a} ⇄ ${b}`, direction, a, b };
        }

        // ⚡ ULTRA高速フロー要素作成
        function createFlowElement(groupType, groupKey, firstPacket) {
            const flowDiv = document.createElement('div');
            flowDiv.className = 'tcp-session'; // CSSは再利用
            flowDiv.id = `flow-${groupType}-${groupKey.replace(/[^a-zA-Z0-9]/g, '-')}`;
            
            const { icon, title, subtitle } = getFlowDisplayInfo(groupType, groupKey, firstPacket);
            const timestamp = new Date(firstPacket.timestamp * 1000).toLocaleTimeString();
            
            flowDiv.innerHTML = `
                <div class="session-header" onclick="toggleFlowUltraFast('${flowDiv.id}')">
                    <div class="session-info">
                        <div class="session-title">${icon} ${title}</div>
                        <div class="session-subtitle">
                            <span class="session-stats">
                                <span>開始: ${timestamp}</span>
                                <span>パケット: <span id="${flowDiv.id}-count">1</span></span>
                                <span>送信: <span id="${flowDiv.id}-sent">0B</span></span>
                                <span>受信: <span id="${flowDiv.id}-recv">0B</span></span>
                                <span>${subtitle}</span>
                            </span>
                        </div>
                    </div>
                    <div class="session-toggle collapsed" id="${flowDiv.id}-toggle">▶</div>
                </div>
                <div class="session-packets collapsed" id="${flowDiv.id}-packets">
                    <div class="loading-skeleton" style="display: none;">
                        <div class="skeleton-line"></div>
                        <div class="skeleton-line"></div>
                        <div class="skeleton-line"></div>
                    </div>
                </div>
            `;
            
            return flowDiv;
        }
        
        function getFlowDisplayInfo(groupType, groupKey, packet) {
            switch (groupType) {
                case 'tcp_sessions':
                    return { 
                        icon: '🔐', 
                        title: groupKey, 
                        subtitle: `TCPセッション` 
                    };
                case 'udp_flows':
                    return { 
                        icon: '📦', 
                        title: groupKey, 
                        subtitle: `UDP通信` 
                    };
                default:
                    return { 
                        icon: '❓', 
                        title: groupKey, 
                        subtitle: `${packet.protocol}プロトコル` 
                    };
            }
        }

        function processPacketQueue() {
            if (packetQueue.length === 0) {
                isProcessingQueue = false;
                return;
            }
            
            isProcessingQueue = true;
            const startTime = performance.now();
            const maxProcessingTime = 8; // 8msまで処理
            
            while (packetQueue.length > 0 && (performance.now() - startTime) < maxProcessingTime) {
                const packet = packetQueue.shift();
                processPacket(packet);
            }
            
            if (packetQueue.length > 0) {
                // まだパケットが残っている場合は次のフレームで続きを処理
                requestAnimationFrame(processPacketQueue);
            } else {
                isProcessingQueue = false;
                // ソートが必要な場合はここで実行
                if (shouldSort) {
                    shouldSort = false;
                    sortFlows(); // 正しい関数名に修正
                }
            }
        }

        function processPacket(packet) {
            // localhostフィルタリング機能
            const hideLocalhost = getCachedElement('hideLocalhost').checked;
            if (hideLocalhost && isLocalhostTraffic(packet)) {
                return; // localhost通信は表示しない
            }
            addPacketToFlow(packet); // 新しいスマートフロー処理
        }

        // 🚀 ULTRAスマートパケット処理
        function addPacketToFlow(packet) {
            const classification = classifyPacket(packet);
            const { type, key, direction, a, b } = classification;
            
            let flowElement = smartGroups[type].get(key);
            
            if (!flowElement) {
                // 新しいフローを作成
                flowElement = createFlowElement(type, key, packet);
                smartGroups[type].set(key, flowElement);
                
                // メタデータを初期化
                const metadata = {
                    type: type,
                    key: key,
                    packetCount: 0,
                    packets: [],
                    firstSeen: packet.timestamp,
                    lastSeen: packet.timestamp,
                    packetsContainer: flowElement.querySelector('.session-packets'),
                    countElement: flowElement.querySelector(`#${flowElement.id}-count`),
                    sentElement: flowElement.querySelector(`#${flowElement.id}-sent`),
                    recvElement: flowElement.querySelector(`#${flowElement.id}-recv`),
                    endpointA: a,
                    endpointB: b,
                    sentBytes: 0,
                    recvBytes: 0,
                    isExpanded: false
                };
                
                groupMetadata.set(`${type}-${key}`, metadata);
                flowList.insertBefore(flowElement, flowList.firstChild);
                shouldSort = true;
            }
            
            const metadata = groupMetadata.get(`${type}-${key}`);
            metadata.packets.push(packet);
            metadata.packetCount++;
            metadata.lastSeen = packet.timestamp;
            metadata.countElement.textContent = metadata.packetCount;
            if (direction === 'a_to_b') {
                metadata.sentBytes += packet.length;
                metadata.sentElement.textContent = formatBytes(metadata.sentBytes);
            } else {
                metadata.recvBytes += packet.length;
                metadata.recvElement.textContent = formatBytes(metadata.recvBytes);
            }
            
            if (metadata.isExpanded) {
                addPacketToExpandedFlow(metadata, packet);
            }
            
            estimatedMemoryUsage += 0.001;
            checkLimits();
        }
        
        function addPacketToExpandedFlow(metadata, packet) {
            const packetsContainer = metadata.packetsContainer;
            const skeleton = packetsContainer.querySelector('.loading-skeleton');
            if (skeleton) skeleton.style.display = 'none';
            
            const packetDiv = document.createElement('div');
            packetDiv.className = 'session-packet';
            
            const timestamp = formatTimestamp(packet.timestamp);
            packetDiv.innerHTML = `
                <div><strong>${packet.src_ip} → ${packet.dst_ip}</strong></div>
                <div>${timestamp} | ${packet.length} bytes | ${packet.protocol}</div>
                <div style="color: #718096; margin-top: 0.25rem;">${packet.info}</div>
            `;
            
            packetsContainer.insertBefore(packetDiv, packetsContainer.firstChild);
            
            // パケット数制限
            const maxPacketsPerSession = parseInt(getCachedElement('maxPacketsPerSession').value) || 50;
            while (packetsContainer.children.length > maxPacketsPerSession + 1) { // +1 for skeleton
                packetsContainer.removeChild(packetsContainer.lastChild);
            }
        }

        // ⚡ ULTRA高速フロートグル (0.1秒以内表示)
        function toggleFlowUltraFast(flowId) {
            const packetsContainer = document.getElementById(`${flowId}-packets`);
            const toggleIcon = document.getElementById(`${flowId}-toggle`);
            const skeleton = packetsContainer.querySelector('.loading-skeleton');
            
            if (packetsContainer.classList.contains('collapsed')) {
                // ✨ 即座スケルトン表示 (0.01秒)
                packetsContainer.classList.remove('collapsed');
                toggleIcon.classList.remove('collapsed');
                toggleIcon.textContent = '▼';
                
                if (skeleton) skeleton.style.display = 'block';
                
                // メタデータを取得
                const metadataKey = flowId.replace('flow-', '').replace(/-/g, '-', 1);
                const metadata = Array.from(groupMetadata.values()).find(m => 
                    flowId.includes(m.type) && flowId.includes(m.key.replace(/[^a-zA-Z0-9]/g, '-'))
                );
                
                if (metadata) {
                    metadata.isExpanded = true;
                    // 非同期でパケットをロード
                    requestIdleCallback(() => loadPacketsChunked(metadata));
                }
                
            } else {
                packetsContainer.classList.add('collapsed');
                toggleIcon.classList.add('collapsed');
                toggleIcon.textContent = '▶';
                
                // メタデータを更新
                const metadataKey = flowId.replace('flow-', '').replace(/-/g, '-', 1);
                const metadata = Array.from(groupMetadata.values()).find(m => 
                    flowId.includes(m.type) && flowId.includes(m.key.replace(/[^a-zA-Z0-9]/g, '-'))
                );
                
                if (metadata) {
                    metadata.isExpanded = false;
                }
            }
        }
        
        // 🚀 チャンク化超高速ローディング
        function loadPacketsChunked(metadata) {
            const packetsContainer = metadata.packetsContainer;
            const skeleton = packetsContainer.querySelector('.loading-skeleton');
            const packets = metadata.packets;
            
            if (packets.length === 0) {
                if (skeleton) skeleton.style.display = 'none';
                return;
            }
            
            const chunkSize = 20; // 20件ずつロード
            let currentIndex = 0;
            
            function loadChunk() {
                const endIndex = Math.min(currentIndex + chunkSize, packets.length);
                const fragment = document.createDocumentFragment();
                
                for (let i = currentIndex; i < endIndex; i++) {
                    const packet = packets[packets.length - 1 - i]; // 新しい順
                    const packetDiv = document.createElement('div');
                    packetDiv.className = 'session-packet';
                    
                    const timestamp = formatTimestamp(packet.timestamp);
                    packetDiv.innerHTML = `
                        <div><strong>${packet.src_ip} → ${packet.dst_ip}</strong></div>
                        <div>${timestamp} | ${packet.length} bytes | ${packet.protocol}</div>
                        <div style="color: #718096; margin-top: 0.25rem;">${packet.info}</div>
                    `;
                    
                    fragment.appendChild(packetDiv);
                }
                
                if (skeleton && skeleton.parentNode) {
                    packetsContainer.insertBefore(fragment, skeleton);
                } else {
                    packetsContainer.appendChild(fragment);
                }
                
                currentIndex = endIndex;
                
                if (currentIndex < packets.length && metadata.isExpanded) {
                    // 次のチャンクを非同期でロード
                    requestAnimationFrame(loadChunk);
                } else {
                    // ローディング完了
                    if (skeleton) skeleton.style.display = 'none';
                }
            }
            
            // 最初のチャンクを即座ロード
            loadChunk();
        }

        function refreshSessionPackets(sessionId) {
            // 必要に応じてセッションのパケットを再描画
            // パフォーマンス向上のため、現在は実装省略
        }

        function getCachedElement(id) {
            if (!cachedElements.has(id)) {
                cachedElements.set(id, document.getElementById(id));
            }
            return cachedElements.get(id);
        }
        
        function formatTimestamp(timestamp) {
            return new Date(timestamp * 1000).toLocaleTimeString();
        }

        function formatBytes(bytes) {
            if (bytes < 1024) return `${bytes}B`;
            if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)}KB`;
            return `${(bytes / (1024*1024)).toFixed(1)}MB`;
        }
        
        function checkLimits() {
            // 定期的なチェックを行う
            if (Math.random() < 0.01) { // 1%の確率でチェック
                const maxSessions = parseInt(getCachedElement('maxSessions').value) || 20;
                const memoryLimit = parseInt(getCachedElement('memoryLimit').value) || 50;
                
                if (estimatedMemoryUsage > memoryLimit) {
                    cleanupOldFlows();
                }
                
                const totalFlows = groupMetadata.size;
                if (totalFlows > maxSessions) {
                    const oldestFlow = flowList.lastChild;
                    if (oldestFlow) {
                        const oldestKey = Array.from(groupMetadata.keys()).find(key => {
                            const metadata = groupMetadata.get(key);
                            return metadata && smartGroups[metadata.type].get && 
                                   smartGroups[metadata.type].get(metadata.key) === oldestFlow;
                        });
                        if (oldestKey) {
                            removeFlow(oldestKey);
                        }
                    }
                }
                
                updateMemoryDisplay();
            }
        }

        function scheduleBatchUpdate() {
            if (pendingUpdates) return;
            
            pendingUpdates = true;
            if (batchUpdateTimer) {
                clearTimeout(batchUpdateTimer);
            }
            
            batchUpdateTimer = setTimeout(() => {
                performBatchUpdate();
                pendingUpdates = false;
            }, 500); // 500msに延長
        }
        
        function performBatchUpdate() {
            updateMemoryDisplay();
            if (shouldSort) {
                shouldSort = false;
                sortFlows();
            }
        }

        function sortFlows() {
            const sortOption = getCachedElement('sortSessions').value;
            const allFlows = [];
            
            // 全てのグループからフローを収集
            Object.keys(smartGroups).forEach(groupType => {
                const group = smartGroups[groupType];
                for (const [key, element] of group.entries()) {
                    allFlows.push({ key: `${groupType}-${key}`, element });
                }
            });
            
            allFlows.sort((a, b) => {
                const metaA = groupMetadata.get(a.key);
                const metaB = groupMetadata.get(b.key);
                
                if (!metaA || !metaB) return 0;
                
                switch (sortOption) {
                    case 'traffic':
                        const bytesA = (metaA.sentBytes || 0) + (metaA.recvBytes || 0);
                        const bytesB = (metaB.sentBytes || 0) + (metaB.recvBytes || 0);
                        return bytesB - bytesA;
                    case 'alphabetical':
                        return a.key.localeCompare(b.key);
                    case 'recent':
                    default:
                        return metaB.lastSeen - metaA.lastSeen;
                }
            });
            
            const fragment = document.createDocumentFragment();
            allFlows.forEach(({ element }) => {
                if (element && element.parentNode) {
                    fragment.appendChild(element);
                }
            });
            flowList.appendChild(fragment);
        }

        function estimatePacketMemoryUsage(packet) {
            // パケット1個あたりの概算メモリ使用量（MB）
            const baseSize = 0.001; // 1KB程度
            const infoSize = packet.info.length * 0.000001; // 文字数に応じて
            return baseSize + infoSize;
        }

        function updateMemoryDisplay() {
            memoryStatusEl.textContent = `メモリ: ${estimatedMemoryUsage.toFixed(1)}MB`;
            
            // メモリ使用量が制限に近づいたら警告色
            const memoryLimit = parseInt(document.getElementById('memoryLimit').value) || 50;
            if (estimatedMemoryUsage > memoryLimit * 0.8) {
                memoryStatusEl.style.color = '#e53e3e';
            } else if (estimatedMemoryUsage > memoryLimit * 0.6) {
                memoryStatusEl.style.color = '#ed8936';
            } else {
                memoryStatusEl.style.color = '#718096';
            }
        }

        function removeFlow(metadataKey) {
            const metadata = groupMetadata.get(metadataKey);
            if (!metadata) return;
            
            const { type, key } = metadata;
            const flowElement = smartGroups[type].get(key);
            
            if (flowElement && flowElement.parentNode) {
                // メモリ使用量を概算で削除
                estimatedMemoryUsage -= metadata.packetCount * 0.001;
                
                smartGroups[type].delete(key);
                flowList.removeChild(flowElement);
                groupMetadata.delete(metadataKey);
            }
        }

        function cleanupOldFlows() {
            // 古いフローから削除
            const flows = Array.from(groupMetadata.entries())
                .sort(([,a], [,b]) => a.lastSeen - b.lastSeen); // 古い順
            
            const memoryLimit = parseInt(getCachedElement('memoryLimit').value) || 50;
            
            while (estimatedMemoryUsage > memoryLimit * 0.7 && flows.length > 0) {
                const [oldestKey] = flows.shift();
                removeFlow(oldestKey);
            }
        }

        async function applyTsharkFilter() {
            const filterValue = document.getElementById('tsharkFilter').value.trim();
            
            try {
                const response = await fetch('/api/filter', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        tshark_filter: filterValue || null
                    })
                });
                
                if (response.ok) {
                    console.log('フィルタが適用されました:', filterValue);
                    // フローリストをクリア（新しいフィルタで再開）
                    flowList.innerHTML = '';
                    Object.keys(smartGroups).forEach(groupType => {
                        smartGroups[groupType].clear();
                    });
                    groupMetadata.clear();
                    packetQueue.length = 0;
                    estimatedMemoryUsage = 0;
                    updateMemoryDisplay();
                } else {
                    console.error('フィルタの適用に失敗しました');
                }
            } catch (error) {
                console.error('フィルタ適用エラー:', error);
            }
        }

        function addPacketToLog(packet) {
            // localhostフィルタリング機能
            const hideLocalhost = document.getElementById('hideLocalhost').checked;
            if (hideLocalhost && isLocalhostTraffic(packet)) {
                return; // localhost通信は表示しない
            }

            const packetDiv = document.createElement('div');
            packetDiv.className = 'packet-item';
            
            const timestamp = new Date(packet.timestamp * 1000).toLocaleTimeString();
            
            packetDiv.innerHTML = `
                <div class="packet-info">
                    <div class="packet-main">${packet.src_ip} → ${packet.dst_ip}</div>
                    <div class="packet-detail">${timestamp} | ${packet.length} bytes | ${packet.info}</div>
                </div>
                <div class="packet-protocol">${packet.protocol}</div>
            `;

            packetList.insertBefore(packetDiv, packetList.firstChild);

            // 最大100個のパケットログを保持
            while (packetList.children.length > 100) {
                packetList.removeChild(packetList.lastChild);
            }
        }

        async function updateStats() {
            try {
                const response = await fetch('/api/stats');
                const stats = await response.json();
                
                console.log('統計情報を取得:', stats);
                
                updateProtocolStats(stats.protocols);
                updateTopStats('sourceStats', stats.top_sources);
                updateTopStats('destStats', stats.top_destinations);
            } catch (error) {
                console.error('統計情報の取得に失敗:', error);
            }
        }

        function updateProtocolStats(protocols) {
            const container = getCachedElement('protocolStats');
            if (!container) {
                console.error('protocolStats要素が見つかりません');
                return;
            }
            
            container.innerHTML = '';
            
            console.log('プロトコル統計更新:', protocols);
            
            const sorted = Object.entries(protocols)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 5);
            
            if (sorted.length === 0) {
                container.innerHTML = '<div class="stat-item"><span>データなし</span><span>-</span></div>';
                return;
            }
            
            sorted.forEach(([protocol, count]) => {
                const item = document.createElement('div');
                item.className = 'stat-item';
                item.innerHTML = `<span>${protocol.toUpperCase()}</span><span>${count}</span>`;
                container.appendChild(item);
            });
        }

        function updateTopStats(containerId, data) {
            const container = getCachedElement(containerId);
            if (!container) {
                console.error(`${containerId}要素が見つかりません`);
                return;
            }
            
            container.innerHTML = '';
            
            const sorted = Object.entries(data)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 5);
            
            if (sorted.length === 0) {
                container.innerHTML = '<div class="stat-item"><span>データなし</span><span>-</span></div>';
                return;
            }
            
            sorted.forEach(([ip, count]) => {
                const item = document.createElement('div');
                item.className = 'stat-item';
                item.innerHTML = `<span>${ip}</span><span>${count}</span>`;
                container.appendChild(item);
            });
        }

        startBtn.addEventListener('click', function() {
            if (!isRunning) {
                connectWebSocket();
            }
        });

        stopBtn.addEventListener('click', function() {
            if (ws && isRunning) {
                ws.close();
            }
        });

        clearBtn.addEventListener('click', function() {
            flowList.innerHTML = '';
            // 全てのスマートグループをクリア
            Object.keys(smartGroups).forEach(groupType => {
                smartGroups[groupType].clear();
            });
            groupMetadata.clear();
            packetQueue.length = 0; // キューもクリア
            packetCount = 0;
            estimatedMemoryUsage = 0;
            totalPacketsEl.textContent = '0';
            updateMemoryDisplay();
        });

        // ソート機能のイベントリスナー
        getCachedElement('sortSessions').addEventListener('change', function() {
            sortFlows(); // 即座ソート実行
        });

        // ネットマスク変更時はフローをリセット
        netmaskSelect.addEventListener('change', function() {
            clearBtn.click();
        });

        // フィルタ適用ボタンのイベントリスナー
        applyFilterBtn.addEventListener('click', applyTsharkFilter);

        // Enterキーでフィルタ適用
        document.getElementById('tsharkFilter').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                applyTsharkFilter();
            }
        });

        // 統計情報を定期的に更新
        setInterval(updateStats, 5000); // 5秒に戻す
        
        // メモリ表示更新の定期実行
        setInterval(updateMemoryDisplay, 2000);
        
        // 初回統計情報を取得
        updateStats();

        // 初期接続
        connectWebSocket();
    </script>
</body>
</html>