<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebShark - Network Packet Visualizer</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <!--
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a202c;
            color: #e2e8f0;
            min-height: 100vh;
        }

        .header {
            background: #2d3748;
            padding: 1rem;
            text-align: center;
            color: #edf2f7;
            border-bottom: 1px solid #4a5568;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .card {
            background: #2d3748;
            border-radius: 15px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid #4a5568;
        }

        .card h3 {
            color: #4a5568;
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid #e2e8f0;
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .packet-log {
            grid-column: 1 / -1;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 1.5rem;
        }

        .packet-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: #1f2937;
            border-radius: 8px;
            border-left: 4px solid #4299e1;
            animation: slideIn 0.3s ease-out;
        }

        .packet-item:nth-child(even) {
            background: #27303f;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .packet-info {
            display: flex;
            flex-direction: column;
            flex: 1;
        }

        .packet-main {
            font-weight: 600;
            color: #edf2f7;
        }

        .packet-detail {
            font-size: 0.85rem;
            color: #a0aec0;
        }

        .packet-protocol {
            background: #4299e1;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .tcp-session {
            margin-bottom: 1rem;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background: #f7fafc;
        }

        .session-header {
            padding: 1rem;
            background: #edf2f7;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            transition: background-color 0.2s ease;
        }

        .session-header:hover {
            background: #e2e8f0;
        }

        .session-info {
            display: flex;
            flex-direction: column;
        }

        .session-title {
            font-weight: 600;
            color: #2d3748;
            font-size: 1rem;
        }

        .session-subtitle {
            font-size: 0.85rem;
            color: #718096;
            margin-top: 0.25rem;
        }

        .session-toggle {
            font-size: 1.2rem;
            color: #4a5568;
            transition: transform 0.2s ease;
        }

        .session-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .session-packets {
            padding: 0 1rem 1rem 1rem;
        }

        .session-packets.collapsed {
            display: none;
        }

        .session-packet {
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            background: white;
            border-radius: 4px;
            border-left: 3px solid #4299e1;
            font-size: 0.85rem;
        }

        .session-stats {
            display: flex;
            gap: 1rem;
            font-size: 0.75rem;
            color: #718096;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #48bb78;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(72, 187, 120, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(72, 187, 120, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(72, 187, 120, 0);
            }
        }

        .controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .filter-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .checkbox-container input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-container label {
            cursor: pointer;
            font-weight: 500;
            color: #4a5568;
        }

        .sort-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255, 255, 255, 0.95);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .sort-controls label {
            font-weight: 500;
            color: #4a5568;
            white-space: nowrap;
        }

        .sort-controls select {
            padding: 0.5rem;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            background: white;
            color: #4a5568;
            cursor: pointer;
        }

        .advanced-controls {
            grid-column: 1 / -1;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 1rem;
        }

        .control-row {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: #f7fafc;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .control-group label {
            font-weight: 500;
            color: #4a5568;
            white-space: nowrap;
        }

        .control-group input, .control-group select {
            padding: 0.5rem;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            background: white;
            color: #4a5568;
        }

        .filter-input {
            width: 300px;
            font-family: monospace;
        }

        .memory-info {
            font-size: 0.85rem;
            color: #718096;
            margin-left: 0.5rem;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            background: #4299e1;
            color: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: #3182ce;
            transform: translateY(-2px);
        }

        .btn.danger {
            background: #e53e3e;
        }

        .btn.danger:hover {
            background: #c53030;
        }

        .tabs {
            display: flex;
            gap: 0;
            justify-content: center;
            background: #2d3748;
            padding: 0.5rem 0;
            position: relative;
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .tabs::-webkit-scrollbar {
            display: none;
        }

        .tab-btn {
            background: transparent;
            border: none;
            color: #a0aec0;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            transition: all 0.3s ease;
            position: relative;
            white-space: nowrap;
            font-weight: 500;
            font-size: 0.95rem;
            min-width: 140px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            justify-content: center;
        }

        .tab-btn:hover {
            background: #4a5568;
            color: #e2e8f0;
            transform: translateY(-2px);
        }

        .tab-btn.active {
            background: #4299e1;
            color: white;
            box-shadow: 0 4px 12px rgba(66, 153, 225, 0.4);
        }

        .tab-btn.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #4299e1, #63b3ed);
            border-radius: 2px;
        }

        .tab-badge {
            background: #e53e3e;
            color: white;
            font-size: 0.7rem;
            padding: 0.2rem 0.4rem;
            border-radius: 10px;
            font-weight: 600;
            min-width: 18px;
            text-align: center;
            animation: pulse 2s infinite;
        }

        .tab-badge.zero {
            background: #718096;
            animation: none;
        }

        .tab-icon {
            font-size: 1.1rem;
        }

        .tab-content {
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s ease;
        }

        .tab-content.active {
            opacity: 1;
            transform: translateY(0);
        }

        .tab-shortcuts {
            position: absolute;
            top: 0.5rem;
            right: 1rem;
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .shortcut-hint {
            background: rgba(255, 255, 255, 0.1);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            color: #a0aec0;
        }

        .search-container {
            position: relative;
            margin: 1rem 0;
            max-width: 400px;
        }

        .search-input {
            width: 100%;
            padding: 0.75rem 1rem 0.75rem 2.5rem;
            border: 2px solid #4a5568;
            border-radius: 8px;
            background: #2d3748;
            color: #e2e8f0;
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: #4299e1;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1);
        }

        .search-icon {
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
            color: #a0aec0;
            font-size: 1rem;
        }

        .tab-context-menu {
            position: absolute;
            background: #2d3748;
            border: 1px solid #4a5568;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 0.5rem 0;
            z-index: 1000;
            min-width: 180px;
            display: none;
        }

        .context-menu-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            color: #e2e8f0;
            transition: background 0.2s ease;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            font-size: 0.9rem;
        }

        .context-menu-item:hover {
            background: #4a5568;
        }

        .context-menu-item.danger {
            color: #fc8181;
        }

        .context-menu-item.danger:hover {
            background: #742a2a;
        }

        @media (max-width: 768px) {
            .tabs {
                padding: 0.25rem 0;
            }
            
            .tab-btn {
                padding: 0.5rem 1rem;
                min-width: 100px;
                font-size: 0.85rem;
            }
            
            .tab-shortcuts {
                display: none;
            }
        }

        .view {
            display: none;
        }

        .view.active {
            display: block;
        }

        /* Enhanced performance optimizations */
        .tab-btn {
            will-change: transform, background-color;
        }

        .tab-content {
            will-change: opacity, transform;
        }

        /* Focus indicators for accessibility */
        .tab-btn:focus {
            outline: 2px solid #4299e1;
            outline-offset: 2px;
        }

        .search-input:focus {
            outline: none;
            border-color: #4299e1;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1);
        }

        #vizView .viz-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            padding: 2rem;
            max-width: 1400px;
            margin: 0 auto;
        }

        .viz-card {
            background: #2d3748;
            border-radius: 15px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid #4a5568;
            min-height: 350px;
            display: flex;
            flex-direction: column;
        }

        .viz-card h3 {
            color: #4299e1;
            margin-bottom: 0.5rem;
            font-size: 1.2rem;
            text-align: center;
        }

        .viz-card .viz-description {
            color: #a0aec0;
            font-size: 0.9rem;
            margin-bottom: 1rem;
            text-align: center;
        }

        .viz-card .viz-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .viz-card canvas {
            max-width: 100%;
            max-height: 280px;
        }

        .viz-card svg {
            max-width: 100%;
            max-height: 280px;
        }

        .viz-placeholder {
            color: #718096;
            font-style: italic;
            text-align: center;
        }

        /* âš¡ ULTRAfast loading skeleton */
        .loading-skeleton {
            animation: skeleton-loading 1.5s infinite;
        }
        
        .skeleton-line {
            height: 16px;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            border-radius: 4px;
            margin-bottom: 8px;
            animation: skeleton-shimmer 1.5s infinite;
        }
        
        @keyframes skeleton-shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        
        .ultra-fast-expand {
            transition: max-height 0.15s ease-out;
        }
        
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }

            .container {
                padding: 1rem;
            }

            #vizView .viz-container {
                grid-template-columns: 1fr;
            }
        }
    -->
</head>
<body>
    <div class="header">
        <h1>ğŸ¦ˆ WebShark</h1>
        <p>Real-time Network Traffic Monitoring</p>
    </div>

    <div class="tabs" role="tablist">
        <button class="tab-btn active" id="topTab" role="tab" aria-selected="true" aria-controls="topView" tabindex="0">
            <span class="tab-icon">ğŸ“Š</span>
            <span>ãƒˆãƒƒãƒ—ãƒ“ãƒ¥ãƒ¼</span>
            <span class="tab-badge zero" id="topTabBadge">0</span>
        </button>
        <button class="tab-btn" id="vizTab" role="tab" aria-selected="false" aria-controls="vizView" tabindex="-1">
            <span class="tab-icon">ğŸ“ˆ</span>
            <span>å¯è¦–åŒ–ãƒ“ãƒ¥ãƒ¼</span>
            <span class="tab-badge zero" id="vizTabBadge">0</span>
        </button>
        
        <div class="tab-shortcuts">
            <span class="shortcut-hint" title="Switch tabs">Alt+1/2</span>
            <span class="shortcut-hint" title="Search">Ctrl+F</span>
        </div>
    </div>

    <!-- Context Menu for Tabs -->
    <div class="tab-context-menu" id="tabContextMenu">
        <button class="context-menu-item" onclick="refreshCurrentTab()">
            <span>ğŸ”„</span> Refresh Tab
        </button>
        <button class="context-menu-item" onclick="clearCurrentTab()">
            <span>ğŸ—‘ï¸</span> Clear Data
        </button>
        <button class="context-menu-item" onclick="exportTabData()">
            <span>ğŸ’¾</span> Export Data
        </button>
        <button class="context-menu-item danger" onclick="resetAllTabs()">
            <span>âš ï¸</span> Reset All
        </button>
    </div>

    <div id="topView" class="view tab-content active" role="tabpanel" aria-labelledby="topTab">
    <div class="container">
        <!-- Search functionality for Top View -->
        <div class="search-container">
            <span class="search-icon">ğŸ”</span>
            <input type="text" class="search-input" id="topViewSearch" placeholder="Search flows, IPs, protocols...">
        </div>
        <div class="controls">
            <button class="btn" id="startBtn">Start</button>
            <button class="btn danger" id="stopBtn">Stop</button>
            <button class="btn" id="clearBtn">Clear Log</button>
            
            <div class="filter-controls">
                <div class="checkbox-container">
                    <input type="checkbox" id="hideLocalhost" checked>
                    <label for="hideLocalhost">Hide localhost traffic</label>
                </div>
            </div>
            
            <div class="sort-controls">
                <label for="sortSessions">Sort by:</label>
                <select id="sortSessions">
                    <option value="recent">Most Recent</option>
                    <option value="traffic">Traffic Volume</option>
                    <option value="alphabetical">Alphabetical</option>
                </select>
            </div>
        </div>

        <div class="status">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Waiting...</span>
            <span id="memoryStatus" class="memory-info">Memory: 0MB</span>
        </div>

        <div class="advanced-controls">
            <h3>ğŸ”§ Advanced Settings</h3>
            <div class="control-row">
                <div class="control-group">
                    <label for="memoryLimit">Memory Limit:</label>
                    <input type="number" id="memoryLimit" value="50" min="10" max="500" step="10">
                    <span>MB</span>
                </div>
                
                <div class="control-group">
                    <label for="maxSessions">Max Sessions:</label>
                    <input type="number" id="maxSessions" value="20" min="5" max="100" step="5">
                </div>
                
                <div class="control-group">
                    <label for="maxPacketsPerSession">Max Packets per Session:</label>
                    <input type="number" id="maxPacketsPerSession" value="50" min="10" max="200" step="10">
                </div>

                <div class="control-group">
                    <input type="checkbox" id="groupLanWan" checked>
                    <label for="groupLanWan">Group by LAN/WAN</label>
                </div>
            </div>
            
            <div class="control-row">
                <div class="control-group">
                    <label for="tsharkFilter">tshark Filter:</label>
                    <input type="text" id="tsharkFilter" class="filter-input" placeholder="e.g. tcp port 80 or udp port 53">
                    <button class="btn" id="applyFilterBtn">Apply</button>
                </div>
            </div>
        </div>

        <div class="dashboard">
            <div class="card">
                <h3>ğŸ“Š Statistics</h3>
                <div class="stat-item">
                    <span>Total Packets:</span>
                    <span id="totalPackets">0</span>
                </div>
                <div class="stat-item">
                    <span>Connection:</span>
                    <span id="connectionStatus">Disconnected</span>
                </div>
            </div>

            <div class="card">
                <h3>ğŸ”— By Protocol</h3>
                <div id="protocolStats">
                    <div class="stat-item">
                        <span>No data</span>
                        <span>-</span>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>ğŸ“ Top Sources</h3>
                <div id="sourceStats">
                    <div class="stat-item">
                        <span>No data</span>
                        <span>-</span>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>ğŸ¯ Top Destinations</h3>
                <div id="destStats">
                    <div class="stat-item">
                        <span>No data</span>
                        <span>-</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="card packet-log">
            <h3>ğŸ“¡ Smart Communication Flows</h3>
            <div id="flowList"></div>
        </div>
    </div>
    </div>

        <div id="vizView" class="view tab-content" role="tabpanel" aria-labelledby="vizTab">
        <div class="container">
            <!-- Search functionality for Visualization View -->
            <div class="search-container">
                <span class="search-icon">ğŸ“Š</span>
                <input type="text" class="search-input" id="vizViewSearch" placeholder="Filter visualizations, hosts...">
            </div>
            
            <div class="viz-container">
                <!-- Row 1 -->
                <div class="viz-card">
                    <h3>ğŸ”— ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å›³</h3>
                    <div class="viz-description">ãƒ›ã‚¹ãƒˆé–“ã®é€šä¿¡ãƒ•ãƒ­ãƒ¼ã‚’å¯è¦–åŒ–</div>
                    <div class="viz-content">
                        <svg id="chordDiagram" width="300" height="280"></svg>
                    </div>
                </div>
                
                <div class="viz-card">
                    <h3>ğŸ“ˆ æ™‚ç³»åˆ—ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯</h3>
                    <div class="viz-description">æ™‚é–“çµŒéã«ä¼´ã†ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯é‡ã®å¤‰åŒ–</div>
                    <div class="viz-content">
                        <canvas id="timeChart" height="280"></canvas>
                    </div>
                </div>
                
                <!-- Row 2 -->
                <div class="viz-card">
                    <h3>ğŸ“Š ç´¯ç©ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯</h3>
                    <div class="viz-description">ç·ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯é‡ã®ç´¯ç©æ¨ç§»</div>
                    <div class="viz-content">
                        <canvas id="totalTrafficChart" height="280"></canvas>
                    </div>
                </div>
                
                <div class="viz-card">
                    <h3>ğŸ¯ ãƒ—ãƒ­ãƒˆã‚³ãƒ«åˆ†å¸ƒ</h3>
                    <div class="viz-description">ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ä½¿ç”¨çŠ¶æ³</div>
                    <div class="viz-content">
                        <canvas id="protocolChart" height="280"></canvas>
                    </div>
                </div>
                
                <!-- Row 3 -->
                <div class="viz-card">
                    <h3>ğŸ“¤ ãƒˆãƒƒãƒ—é€ä¿¡å…ƒãƒ›ã‚¹ãƒˆ</h3>
                    <div class="viz-description">æœ€ã‚‚å¤šããƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã—ã¦ã„ã‚‹ãƒ›ã‚¹ãƒˆ</div>
                    <div class="viz-content">
                        <canvas id="topSourcesChart" height="280"></canvas>
                    </div>
                </div>
                
                <div class="viz-card">
                    <h3>ğŸ“¥ ãƒˆãƒƒãƒ—å®›å…ˆãƒ›ã‚¹ãƒˆ</h3>
                    <div class="viz-description">æœ€ã‚‚å¤šããƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡ã—ã¦ã„ã‚‹ãƒ›ã‚¹ãƒˆ</div>
                    <div class="viz-content">
                        <canvas id="topDestinationsChart" height="280"></canvas>
                    </div>
                </div>
                
                <!-- Row 4 -->
                <div class="viz-card">
                    <h3>ğŸ“¦ ãƒ‘ã‚±ãƒƒãƒˆã‚µã‚¤ã‚ºåˆ†å¸ƒ</h3>
                    <div class="viz-description">ãƒ‘ã‚±ãƒƒãƒˆã‚µã‚¤ã‚ºã®çµ±è¨ˆåˆ†å¸ƒ</div>
                    <div class="viz-content">
                        <canvas id="packetSizeChart" height="280"></canvas>
                    </div>
                </div>
                
                <div class="viz-card">
                    <h3>ğŸ”„ æ¥ç¶šçŠ¶æ…‹çµ±è¨ˆ</h3>
                    <div class="viz-description">TCPæ¥ç¶šçŠ¶æ…‹ã¨UDPãƒ•ãƒ­ãƒ¼ã®çµ±è¨ˆ</div>
                    <div class="viz-content">
                        <canvas id="connectionStatesChart" height="280"></canvas>
                    </div>
                </div>
                
                <!-- Row 5 -->
                <div class="viz-card">
                    <h3>ğŸŒ åœ°ç†çš„åˆ†å¸ƒãƒãƒƒãƒ—</h3>
                    <div class="viz-description">IPã‚¢ãƒ‰ãƒ¬ã‚¹ã®åœ°ç†çš„åˆ†å¸ƒï¼ˆå°†æ¥å®Ÿè£…äºˆå®šï¼‰</div>
                    <div class="viz-content">
                        <div class="viz-placeholder">
                            åœ°ç†çš„åˆ†å¸ƒãƒãƒƒãƒ—<br>
                            <small>å°†æ¥ã®æ©Ÿèƒ½æ‹¡å¼µã§å®Ÿè£…äºˆå®š</small>
                        </div>
                    </div>
                </div>
                
                <div class="viz-card">
                    <h3>âš ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¢ãƒ©ãƒ¼ãƒˆ</h3>
                    <div class="viz-description">ç•°å¸¸æ¤œçŸ¥ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¢ãƒ©ãƒ¼ãƒˆï¼ˆå°†æ¥å®Ÿè£…äºˆå®šï¼‰</div>
                    <div class="viz-content">
                        <div class="viz-placeholder">
                            ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¢ãƒ©ãƒ¼ãƒˆ<br>
                            <small>å°†æ¥ã®æ©Ÿèƒ½æ‹¡å¼µã§å®Ÿè£…äºˆå®š</small>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- pako.js for decompression -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="/static/js/app.js"></script>
    <script src="/static/js/ws.js"></script>
<!--
        let packetCount = 0;
        let PROTOCOLS = [];
        let LOCAL_IPS = [];
        // Simple grouping
        let smartGroups = {
            tcp_sessions: new Map(),
            udp_flows: new Map(),
            other_protocols: new Map()
        };
        let groupMetadata = new Map(); // group metadata
        let estimatedMemoryUsage = 0; // estimated memory usage (MB)
        let batchUpdateTimer = null; // batch update timer
        let pendingUpdates = false; // pending update flag
        let packetQueue = []; // packet processing queue
        let isProcessingQueue = false; // queue processing flag
        let cachedElements = new Map(); // DOM element cache
        let shouldSort = false; // whether sorting is needed

        // Enhanced Tab System
        const topTab = document.getElementById('topTab');
        const vizTab = document.getElementById('vizTab');
        const topView = document.getElementById('topView');
        const vizView = document.getElementById('vizView');
        const topTabBadge = document.getElementById('topTabBadge');
        const vizTabBadge = document.getElementById('vizTabBadge');
        const tabContextMenu = document.getElementById('tabContextMenu');
        const topViewSearch = document.getElementById('topViewSearch');
        const vizViewSearch = document.getElementById('vizViewSearch');
        
        let currentTab = 'top';
        let searchFilters = {
            top: '',
            viz: ''
        };
        let tabData = {
            top: { packets: 0, lastUpdate: 0 },
            viz: { packets: 0, lastUpdate: 0 }
        };

        // Chart.js time series
        const timeCtx = document.getElementById('timeChart').getContext('2d');
        const timeChart = new Chart(timeCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Bytes per second',
                    data: [],
                    borderColor: '#4299e1',
                    backgroundColor: 'rgba(66,153,225,0.3)',
                    fill: true,
                    tension: 0.1
                }]
            },
            options: {
                animation: false,
                scales: { x: { display: true }, y: { beginAtZero: true } }
            }
        });

        const trafficSeries = new Map();
        let totalTraffic = 0;

        const totalCtx = document.getElementById('totalTrafficChart').getContext('2d');
        const totalChart = new Chart(totalCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Total Bytes',
                    data: [],
                    borderColor: '#68d391',
                    backgroundColor: 'rgba(104,211,145,0.3)',
                    fill: true,
                    tension: 0.1
                }]
            },
            options: {
                animation: false,
                scales: { x: { display: true }, y: { beginAtZero: true } }
            }
        });

        const protocolCounts = new Map();
        const protocolCtx = document.getElementById('protocolChart').getContext('2d');
        const protocolChart = new Chart(protocolCtx, {
            type: 'doughnut',
            data: {
                labels: [],
                datasets: [{
                    label: 'Protocols',
                    data: [],
                    backgroundColor: [
                        '#4299e1', '#68d391', '#ed8936', '#e53e3e',
                        '#9f7aea', '#ed64a6', '#f6ad55', '#38a169', '#718096'
                    ]
                }]
            },
            options: { animation: false }
        });

        // Top Sources Chart
        const topSourcesData = new Map();
        const topSourcesCtx = document.getElementById('topSourcesChart').getContext('2d');
        const topSourcesChart = new Chart(topSourcesCtx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [{
                    label: 'Packets Sent',
                    data: [],
                    backgroundColor: '#4299e1',
                    borderColor: '#3182ce',
                    borderWidth: 1
                }]
            },
            options: {
                animation: false,
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: { beginAtZero: true }
                }
            }
        });

        // Top Destinations Chart
        const topDestinationsData = new Map();
        const topDestinationsCtx = document.getElementById('topDestinationsChart').getContext('2d');
        const topDestinationsChart = new Chart(topDestinationsCtx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [{
                    label: 'Packets Received',
                    data: [],
                    backgroundColor: '#68d391',
                    borderColor: '#38a169',
                    borderWidth: 1
                }]
            },
            options: {
                animation: false,
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: { beginAtZero: true }
                }
            }
        });

        // Packet Size Distribution Chart
        const packetSizeData = new Map();
        const packetSizeCtx = document.getElementById('packetSizeChart').getContext('2d');
        const packetSizeChart = new Chart(packetSizeCtx, {
            type: 'bar',
            data: {
                labels: ['0-64', '65-128', '129-256', '257-512', '513-1024', '1025-1500', '1501+'],
                datasets: [{
                    label: 'Packet Count',
                    data: [0, 0, 0, 0, 0, 0, 0],
                    backgroundColor: '#ed8936',
                    borderColor: '#dd6b20',
                    borderWidth: 1
                }]
            },
            options: {
                animation: false,
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: { beginAtZero: true }
                }
            }
        });

        // Connection States Chart
        const connectionStatesData = new Map();
        const connectionStatesCtx = document.getElementById('connectionStatesChart').getContext('2d');
        const connectionStatesChart = new Chart(connectionStatesCtx, {
            type: 'pie',
            data: {
                labels: ['TCP Sessions', 'UDP Flows', 'Other Protocols'],
                datasets: [{
                    label: 'Connection Types',
                    data: [0, 0, 0],
                    backgroundColor: ['#9f7aea', '#ed64a6', '#f6ad55']
                }]
            },
            options: {
                animation: false,
                responsive: true,
                maintainAspectRatio: false
            }
        });

        // D3 chord diagram data
        const chordSvg = d3.select('#chordDiagram');
        const hostIndex = new Map();
        let hosts = [];
        let matrix = [];

        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const clearBtn = document.getElementById('clearBtn');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const totalPacketsEl = document.getElementById('totalPackets');
        const connectionStatusEl = document.getElementById('connectionStatus');
        const flowList = document.getElementById('flowList');
        const memoryStatusEl = document.getElementById('memoryStatus');
        const applyFilterBtn = document.getElementById('applyFilterBtn');
        const groupLanWanCheckbox = document.getElementById('groupLanWan');

        // Enhanced Tab Switching with Animation
        function switchTab(targetTab) {
            const tabs = [topTab, vizTab];
            const views = [topView, vizView];
            const tabNames = ['top', 'viz'];
            
            // Update current tab
            currentTab = targetTab;
            
            // Update tab states
            tabs.forEach((tab, index) => {
                const isActive = tabNames[index] === targetTab;
                tab.classList.toggle('active', isActive);
                tab.setAttribute('aria-selected', isActive);
                tab.setAttribute('tabindex', isActive ? '0' : '-1');
                
                // Update view states with animation
                const view = views[index];
                if (isActive) {
                    view.style.display = 'block';
                    requestAnimationFrame(() => {
                        view.classList.add('active');
                    });
                } else {
                    view.classList.remove('active');
                    setTimeout(() => {
                        if (!view.classList.contains('active')) {
                            view.style.display = 'none';
                        }
                    }, 300);
                }
            });
            
            // Save tab preference
            localStorage.setItem('activeTab', targetTab);
            
            // Update search visibility
            updateSearchVisibility();
        }

        // Tab Event Listeners
        topTab.addEventListener('click', () => switchTab('top'));
        vizTab.addEventListener('click', () => switchTab('viz'));

        // Keyboard Navigation
        document.addEventListener('keydown', (e) => {
            // Alt+1/2 for tab switching
            if (e.altKey && (e.key === '1' || e.key === '2')) {
                e.preventDefault();
                switchTab(e.key === '1' ? 'top' : 'viz');
            }
            
            // Ctrl+F for search
            if (e.ctrlKey && e.key === 'f') {
                e.preventDefault();
                const searchInput = currentTab === 'top' ? topViewSearch : vizViewSearch;
                searchInput.focus();
            }
            
            // Arrow keys for tab navigation
            if (e.target.closest('.tabs') && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
                e.preventDefault();
                const currentIndex = currentTab === 'top' ? 0 : 1;
                const newIndex = e.key === 'ArrowLeft' ? 
                    (currentIndex === 0 ? 1 : 0) : 
                    (currentIndex === 1 ? 0 : 1);
                switchTab(newIndex === 0 ? 'top' : 'viz');
            }
        });

        // Tab Context Menu
        [topTab, vizTab].forEach(tab => {
            tab.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showContextMenu(e.clientX, e.clientY);
            });
        });

        // Hide context menu on click outside
        document.addEventListener('click', () => {
            tabContextMenu.style.display = 'none';
        });

        // Enhanced Tab System Functions
        function updateTabBadges() {
            // Update Top View badge with flow count
            const totalFlows = groupMetadata.size;
            topTabBadge.textContent = totalFlows;
            topTabBadge.classList.toggle('zero', totalFlows === 0);
            
            // Update Viz View badge with host count
            const hostCount = hosts.length;
            vizTabBadge.textContent = hostCount;
            vizTabBadge.classList.toggle('zero', hostCount === 0);
            
            // Update tab data
            tabData.top.packets = totalFlows;
            tabData.top.lastUpdate = Date.now();
            tabData.viz.packets = hostCount;
            tabData.viz.lastUpdate = Date.now();
        }

        function showContextMenu(x, y) {
            tabContextMenu.style.left = x + 'px';
            tabContextMenu.style.top = y + 'px';
            tabContextMenu.style.display = 'block';
        }

        function refreshCurrentTab() {
            if (currentTab === 'top') {
                updateStats();
                sortFlows();
            } else {
                drawChordDiagram();
                refreshTimeChart();
                refreshTotalTrafficChart();
                refreshProtocolChart();
                refreshTopSourcesChart();
                refreshTopDestinationsChart();
                refreshPacketSizeChart();
                refreshConnectionStatesChart();
            }
            console.log(`Refreshed ${currentTab} tab`);
        }

        function clearCurrentTab() {
            if (currentTab === 'top') {
                clearBtn.click();
            } else {
                // Clear visualization data
                protocolCounts.clear();
                trafficSeries.clear();
                topSourcesData.clear();
                topDestinationsData.clear();
                packetSizeChart.data.datasets[0].data = [0, 0, 0, 0, 0, 0, 0];
                connectionStatesChart.data.datasets[0].data = [0, 0, 0];
                rebuildHostMatrix();
                drawChordDiagram();
                console.log('Cleared visualization data');
            }
        }

        function exportTabData() {
            const data = {
                tab: currentTab,
                timestamp: new Date().toISOString(),
                data: currentTab === 'top' ? 
                    Array.from(groupMetadata.entries()) : 
                    { hosts, matrix, protocolCounts: Object.fromEntries(protocolCounts) }
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `webshark-${currentTab}-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            console.log(`Exported ${currentTab} tab data`);
        }

        function resetAllTabs() {
            if (confirm('Are you sure you want to reset all tabs? This will clear all data.')) {
                clearBtn.click();
                protocolCounts.clear();
                trafficSeries.clear();
                rebuildHostMatrix();
                drawChordDiagram();
                console.log('Reset all tabs');
            }
        }

        function updateSearchVisibility() {
            const searchContainers = document.querySelectorAll('.search-container');
            searchContainers.forEach(container => {
                container.style.display = 'block';
            });
        }

        // Search Functionality
        function setupSearchFilters() {
            topViewSearch.addEventListener('input', (e) => {
                searchFilters.top = e.target.value.toLowerCase();
                filterTopViewContent();
            });

            vizViewSearch.addEventListener('input', (e) => {
                searchFilters.viz = e.target.value.toLowerCase();
                filterVizViewContent();
            });
        }

        function filterTopViewContent() {
            const query = searchFilters.top;
            const flows = document.querySelectorAll('.tcp-session');
            
            flows.forEach(flow => {
                const text = flow.textContent.toLowerCase();
                const matches = !query || text.includes(query);
                flow.style.display = matches ? 'block' : 'none';
            });
        }

        function filterVizViewContent() {
            const query = searchFilters.viz;
            // Filter hosts in chord diagram
            if (query) {
                const filteredHosts = hosts.filter(host => 
                    host.toLowerCase().includes(query)
                );
                console.log(`Filtered to ${filteredHosts.length} hosts`);
            }
        }

        // Tab Persistence
        function restoreTabState() {
            const savedTab = localStorage.getItem('activeTab');
            if (savedTab && (savedTab === 'top' || savedTab === 'viz')) {
                switchTab(savedTab);
            }
        }

        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            ws = new WebSocket(wsUrl);

            ws.onopen = function() {
                console.log('WebSocket connection established');
                connectionStatusEl.textContent = 'Connected';
                statusText.textContent = 'Capturing packets...';
                statusDot.style.background = '#48bb78';
                isRunning = true;
            };

            ws.onmessage = async function(event) {
                let packets = [];

                if (typeof event.data === 'string') {
                    const msg = JSON.parse(event.data);
                    if (msg.type === 'ctx') {
                        PROTOCOLS = msg.protocols;
                        LOCAL_IPS = msg.local_ips || [];
                        return;
                    }
                    packets = [msg];
                } else if (event.data instanceof Blob) {
                    // Decompress data
                    try {
                        const arrayBuffer = await event.data.arrayBuffer();
                        const decompressed = pako.inflate(new Uint8Array(arrayBuffer), { to: 'string' });
                        packets = JSON.parse(decompressed);
                    } catch (e) {
                        console.error('Failed to decompress data:', e);
                        return;
                    }
                }
                
                // Add batch packets to queue
                packets.forEach(packet => {
                    if (packet.proto !== undefined && PROTOCOLS.length) {
                        packet.protocol = PROTOCOLS[packet.proto] || 'UNKNOWN';
                    }
                    if (packet.sub_proto === null) packet.sub_proto = undefined;
                    packetQueue.push(packet);
                    packetCount++;
                });
                
                totalPacketsEl.textContent = packetCount.toLocaleString();
                
                // Start queue processing
                if (!isProcessingQueue) {
                    requestAnimationFrame(processPacketQueue);
                }
            };

            ws.onclose = function() {
                console.log('WebSocket connection closed');
                connectionStatusEl.textContent = 'Disconnected';
                statusText.textContent = 'Waiting...';
                statusDot.style.background = '#e53e3e';
                isRunning = false;
            };

            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
                connectionStatusEl.textContent = 'Error';
                statusDot.style.background = '#ed8936';
            };
        }

        function isLocalhostTraffic(packet) {
            const localhostAddresses = ['127.0.0.1', '::1', 'localhost'];
            return localhostAddresses.includes(packet.src_ip) || 
                   localhostAddresses.includes(packet.dst_ip) ||
                   (packet.src_ip === packet.dst_ip && 
                    (packet.src_ip.startsWith('127.') || packet.src_ip.startsWith('::1')));
        }

        // ğŸš€ Simple protocol classification
        function classifyPacket(packet) {
            const protocol = packet.protocol.toUpperCase();
            const info = createSessionInfo(packet);

            let type = 'other_protocols';
            if (protocol === 'TCP') type = 'tcp_sessions';
            else if (protocol === 'UDP') type = 'udp_flows';

            return { type, key: info.key, direction: info.direction, a: info.a, b: info.b };
        }

        function isLan(ip) {
            return LOCAL_IPS.includes(ip) ||
                   ip.startsWith('10.') ||
                   ip.startsWith('192.168.') ||
                   (/^172\.(1[6-9]|2\d|3[01])\./.test(ip));
        }

        function getDisplayLabel(ip) {
            return isLan(ip) ? `LAN_${ip}` : `WAN_${ip}`;
        }

        function getDisplayKey(packet) {
            const portMatch = packet.info.match(/(\d+)\s*â†’\s*(\d+)/);
            let src = getDisplayLabel(packet.src_ip);
            let dst = getDisplayLabel(packet.dst_ip);
            if (portMatch) {
                src = `${src}:${portMatch[1]}`;
                dst = `${dst}:${portMatch[2]}`;
            }
            return `${src} â‡„ ${dst}`;
        }

        // create session key and direction
        function createSessionInfo(packet) {
            const portMatch = packet.info.match(/(\d+)\s*â†’\s*(\d+)/);
            let src = packet.src_ip;
            let dst = packet.dst_ip;
            if (groupLanWanCheckbox && groupLanWanCheckbox.checked) {
                src = isLan(packet.src_ip) ? 'LAN' : 'WAN';
                dst = isLan(packet.dst_ip) ? 'LAN' : 'WAN';
            }
            if (portMatch) {
                src = `${src}:${portMatch[1]}`;
                dst = `${dst}:${portMatch[2]}`;
            }
            let a = src;
            let b = dst;
            let direction = 'a_to_b';
            if (a < b) {
                direction = 'a_to_b';
            } else if (a > b) {
                direction = 'b_to_a';
                const tmp = a; a = b; b = tmp;
            } else {
                direction = 'a_to_b';
            }
            return { key: `${a} â‡„ ${b}`, direction, a, b };
        }

        // âš¡ ULTRA fast flow element creation
        function createFlowElement(groupType, groupKey, firstPacket) {
            const flowDiv = document.createElement('div');
            flowDiv.className = 'tcp-session'; // reuse CSS
            flowDiv.id = `flow-${groupType}-${groupKey.replace(/[^a-zA-Z0-9]/g, '-')}`;
            
            const { icon, title, subtitle } = getFlowDisplayInfo(groupType, groupKey, firstPacket);
            const timestamp = new Date(firstPacket.timestamp * 1000).toLocaleTimeString();
            
            flowDiv.innerHTML = `
                <div class="session-header" onclick="toggleFlowUltraFast('${flowDiv.id}')">
                    <div class="session-info">
                        <div class="session-title">${icon} ${title}</div>
                        <div class="session-subtitle">
                            <span class="session-stats">
                                <span>Started: ${timestamp}</span>
                                <span>Packets: <span id="${flowDiv.id}-count">1</span></span>
                                <span>Sent: <span id="${flowDiv.id}-sent">0B</span></span>
                                <span>Received: <span id="${flowDiv.id}-recv">0B</span></span>
                                <span>${subtitle}</span>
                            </span>
                        </div>
                    </div>
                    <div class="session-toggle collapsed" id="${flowDiv.id}-toggle">â–¶</div>
                </div>
                <div class="session-packets collapsed" id="${flowDiv.id}-packets">
                    <div class="loading-skeleton" style="display: none;">
                        <div class="skeleton-line"></div>
                        <div class="skeleton-line"></div>
                        <div class="skeleton-line"></div>
                    </div>
                </div>
            `;
            
            return flowDiv;
        }
        
        function getFlowDisplayInfo(groupType, groupKey, packet) {
            const title = (groupLanWanCheckbox && groupLanWanCheckbox.checked)
                ? getDisplayKey(packet)
                : groupKey;
            switch (groupType) {
                case 'tcp_sessions':
                    const tcpSubtitle = packet.sub_proto ? `${packet.sub_proto} over TCP` : 'TCP Session';
                    return {
                        icon: 'ğŸ”',
                        title: title,
                        subtitle: tcpSubtitle
                    };
                case 'udp_flows':
                    const udpSubtitle = packet.sub_proto ? `${packet.sub_proto} over UDP` : 'UDP Flow';
                    return {
                        icon: 'ğŸ“¦',
                        title: title,
                        subtitle: udpSubtitle
                    };
                default:
                    return {
                        icon: 'â“',
                        title: title,
                        subtitle: `${packet.protocol}Protocol`
                    };
            }
        }

        function processPacketQueue() {
            if (packetQueue.length === 0) {
                isProcessingQueue = false;
                return;
            }
            
            isProcessingQueue = true;
            const startTime = performance.now();
            const maxProcessingTime = 8; // process up to 8ms
            
            while (packetQueue.length > 0 && (performance.now() - startTime) < maxProcessingTime) {
                const packet = packetQueue.shift();
                processPacket(packet);
            }
            
            if (packetQueue.length > 0) {
                // if packets remain continue next frame
                requestAnimationFrame(processPacketQueue);
            } else {
                isProcessingQueue = false;
                // perform sort here if needed
                if (shouldSort) {
                    shouldSort = false;
                    sortFlows(); // call correct function
                }
            }
        }

        function processPacket(packet) {
            // localhost filtering
            const hideLocalhost = getCachedElement('hideLocalhost').checked;
            if (hideLocalhost && isLocalhostTraffic(packet)) {
                return; // skip localhost traffic
            }
            addPacketToFlow(packet); // new smart flow handling
            updateVisualization(packet);
        }

        // ğŸš€ ULTRA smart packet processing
        function addPacketToFlow(packet) {
            const classification = classifyPacket(packet);
            const { type, key, direction, a, b } = classification;
            
            let flowElement = smartGroups[type].get(key);
            
            if (!flowElement) {
                // create new flow
                flowElement = createFlowElement(type, key, packet);
                smartGroups[type].set(key, flowElement);
                
                // initialize metadata
                const metadata = {
                    type: type,
                    key: key,
                    packetCount: 0,
                    packets: [],
                    firstSeen: packet.timestamp,
                    lastSeen: packet.timestamp,
                    packetsContainer: flowElement.querySelector('.session-packets'),
                    countElement: flowElement.querySelector(`#${flowElement.id}-count`),
                    sentElement: flowElement.querySelector(`#${flowElement.id}-sent`),
                    recvElement: flowElement.querySelector(`#${flowElement.id}-recv`),
                    endpointA: a,
                    endpointB: b,
                    sentBytes: 0,
                    recvBytes: 0,
                    isExpanded: false
                };
                
                groupMetadata.set(`${type}-${key}`, metadata);
                flowList.insertBefore(flowElement, flowList.firstChild);
                shouldSort = true;
            }
            
            const metadata = groupMetadata.get(`${type}-${key}`);
            metadata.packets.push(packet);
            metadata.packetCount++;
            metadata.lastSeen = packet.timestamp;
            metadata.countElement.textContent = metadata.packetCount;
            if (direction === 'a_to_b') {
                metadata.sentBytes += packet.length;
                metadata.sentElement.textContent = formatBytes(metadata.sentBytes);
            } else {
                metadata.recvBytes += packet.length;
                metadata.recvElement.textContent = formatBytes(metadata.recvBytes);
            }
            
            if (metadata.isExpanded) {
                addPacketToExpandedFlow(metadata, packet);
            }
            
            estimatedMemoryUsage += 0.001;
            checkLimits();
            
            // Update tab badges
            updateTabBadges();
        }
        
        function addPacketToExpandedFlow(metadata, packet) {
            const packetsContainer = metadata.packetsContainer;
            const skeleton = packetsContainer.querySelector('.loading-skeleton');
            if (skeleton) skeleton.style.display = 'none';
            
            const packetDiv = document.createElement('div');
            packetDiv.className = 'session-packet';
            
            const timestamp = formatTimestamp(packet.timestamp);
            const protoLabel = packet.sub_proto ? `${packet.protocol} (${packet.sub_proto})` : packet.protocol;
            packetDiv.innerHTML = `
                <div><strong>${getDisplayLabel(packet.src_ip)} â†’ ${getDisplayLabel(packet.dst_ip)}</strong></div>
                <div>${timestamp} | ${packet.length} bytes | ${protoLabel}</div>
                <div style="color: #718096; margin-top: 0.25rem;">${packet.info}</div>
            `;
            
            packetsContainer.insertBefore(packetDiv, packetsContainer.firstChild);
            
            // packet limit
            const maxPacketsPerSession = parseInt(getCachedElement('maxPacketsPerSession').value) || 50;
            while (packetsContainer.children.length > maxPacketsPerSession + 1) { // +1 for skeleton
                packetsContainer.removeChild(packetsContainer.lastChild);
            }
        }

        // âš¡ ULTRA fast flow toggle (display within 0.1s)
        function toggleFlowUltraFast(flowId) {
            const packetsContainer = document.getElementById(`${flowId}-packets`);
            const toggleIcon = document.getElementById(`${flowId}-toggle`);
            const skeleton = packetsContainer.querySelector('.loading-skeleton');
            
            if (packetsContainer.classList.contains('collapsed')) {
                // âœ¨ instant skeleton display (0.01s)
                packetsContainer.classList.remove('collapsed');
                toggleIcon.classList.remove('collapsed');
                toggleIcon.textContent = 'â–¼';
                
                if (skeleton) skeleton.style.display = 'block';
                
                // get metadata
                const metadataKey = flowId.replace('flow-', '').replace(/-/g, '-', 1);
                const metadata = Array.from(groupMetadata.values()).find(m => 
                    flowId.includes(m.type) && flowId.includes(m.key.replace(/[^a-zA-Z0-9]/g, '-'))
                );
                
                if (metadata) {
                    metadata.isExpanded = true;
                    // load packets asynchronously
                    requestIdleCallback(() => loadPacketsChunked(metadata));
                }
                
            } else {
                packetsContainer.classList.add('collapsed');
                toggleIcon.classList.add('collapsed');
                toggleIcon.textContent = 'â–¶';
                
                // update metadata
                const metadataKey = flowId.replace('flow-', '').replace(/-/g, '-', 1);
                const metadata = Array.from(groupMetadata.values()).find(m => 
                    flowId.includes(m.type) && flowId.includes(m.key.replace(/[^a-zA-Z0-9]/g, '-'))
                );
                
                if (metadata) {
                    metadata.isExpanded = false;
                }
            }
        }
        
        // ğŸš€ chunked ultra-fast loading
        function loadPacketsChunked(metadata) {
            const packetsContainer = metadata.packetsContainer;
            const skeleton = packetsContainer.querySelector('.loading-skeleton');
            const packets = metadata.packets;
            
            if (packets.length === 0) {
                if (skeleton) skeleton.style.display = 'none';
                return;
            }
            
            const chunkSize = 20; // load 20 items at a time
            let currentIndex = 0;
            
            function loadChunk() {
                const endIndex = Math.min(currentIndex + chunkSize, packets.length);
                const fragment = document.createDocumentFragment();
                
                for (let i = currentIndex; i < endIndex; i++) {
                    const packet = packets[packets.length - 1 - i]; // newest first
                    const packetDiv = document.createElement('div');
                    packetDiv.className = 'session-packet';

                    const timestamp = formatTimestamp(packet.timestamp);
                    const protoLabel = packet.sub_proto ? `${packet.protocol} (${packet.sub_proto})` : packet.protocol;
                    packetDiv.innerHTML = `
                        <div><strong>${getDisplayLabel(packet.src_ip)} â†’ ${getDisplayLabel(packet.dst_ip)}</strong></div>
                        <div>${timestamp} | ${packet.length} bytes | ${protoLabel}</div>
                        <div style="color: #718096; margin-top: 0.25rem;">${packet.info}</div>
                    `;
                    
                    fragment.appendChild(packetDiv);
                }
                
                if (skeleton && skeleton.parentNode) {
                    packetsContainer.insertBefore(fragment, skeleton);
                } else {
                    packetsContainer.appendChild(fragment);
                }
                
                currentIndex = endIndex;
                
                if (currentIndex < packets.length && metadata.isExpanded) {
                    // load next chunk asynchronously
                    requestAnimationFrame(loadChunk);
                } else {
                    // loading complete
                    if (skeleton) skeleton.style.display = 'none';
                }
            }
            
            // load first chunk immediately
            loadChunk();
        }

        function refreshSessionPackets(sessionId) {
            // if necessaryredraw session packets
            // omitted for performance reasons
        }

        function getCachedElement(id) {
            if (!cachedElements.has(id)) {
                cachedElements.set(id, document.getElementById(id));
            }
            return cachedElements.get(id);
        }
        
        function formatTimestamp(timestamp) {
            return new Date(timestamp * 1000).toLocaleTimeString();
        }

        function formatBytes(bytes) {
            if (bytes < 1024) return `${bytes}B`;
            if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)}KB`;
            return `${(bytes / (1024*1024)).toFixed(1)}MB`;
        }
        
        function checkLimits() {
            const maxSessions = parseInt(getCachedElement('maxSessions').value) || 20;
            const memoryLimit = parseInt(getCachedElement('memoryLimit').value) || 50;

            if (estimatedMemoryUsage > memoryLimit) {
                cleanupOldFlows();
            }

            const totalFlows = groupMetadata.size;
            if (totalFlows > maxSessions) {
                const oldestFlow = flowList.lastChild;
                if (oldestFlow) {
                    const oldestKey = Array.from(groupMetadata.keys()).find(key => {
                        const metadata = groupMetadata.get(key);
                        return metadata && smartGroups[metadata.type].get &&
                               smartGroups[metadata.type].get(metadata.key) === oldestFlow;
                    });
                    if (oldestKey) {
                        removeFlow(oldestKey);
                    }
                }
            }

            updateMemoryDisplay();
        }

        function scheduleBatchUpdate() {
            if (pendingUpdates) return;
            
            pendingUpdates = true;
            if (batchUpdateTimer) {
                clearTimeout(batchUpdateTimer);
            }
            
            batchUpdateTimer = setTimeout(() => {
                performBatchUpdate();
                pendingUpdates = false;
            }, 500); // extended to 500ms
        }
        
        function performBatchUpdate() {
            updateMemoryDisplay();
            if (shouldSort) {
                shouldSort = false;
                sortFlows();
            }
        }

        function sortFlows() {
            const sortOption = getCachedElement('sortSessions').value;
            const allFlows = [];
            
            // collect flows from all groups
            Object.keys(smartGroups).forEach(groupType => {
                const group = smartGroups[groupType];
                for (const [key, element] of group.entries()) {
                    allFlows.push({ key: `${groupType}-${key}`, element });
                }
            });
            
            allFlows.sort((a, b) => {
                const metaA = groupMetadata.get(a.key);
                const metaB = groupMetadata.get(b.key);
                
                if (!metaA || !metaB) return 0;
                
                switch (sortOption) {
                    case 'traffic':
                        const bytesA = (metaA.sentBytes || 0) + (metaA.recvBytes || 0);
                        const bytesB = (metaB.sentBytes || 0) + (metaB.recvBytes || 0);
                        return bytesB - bytesA;
                    case 'alphabetical':
                        return a.key.localeCompare(b.key);
                    case 'recent':
                    default:
                        return metaB.lastSeen - metaA.lastSeen;
                }
            });
            
            const fragment = document.createDocumentFragment();
            allFlows.forEach(({ element }) => {
                if (element && element.parentNode) {
                    fragment.appendChild(element);
                }
            });
            flowList.appendChild(fragment);
        }

        function estimatePacketMemoryUsage(packet) {
            // approx memory usage per packet (MB)
            const baseSize = 0.001; // around 1KB
            const infoSize = packet.info.length * 0.000001; // dependent on text length
            return baseSize + infoSize;
        }

        function updateMemoryDisplay() {
            memoryStatusEl.textContent = `Memory: ${estimatedMemoryUsage.toFixed(1)}MB`;
            
            // warn when memory usage near limit
            const memoryLimit = parseInt(document.getElementById('memoryLimit').value) || 50;
            if (estimatedMemoryUsage > memoryLimit * 0.8) {
                memoryStatusEl.style.color = '#e53e3e';
            } else if (estimatedMemoryUsage > memoryLimit * 0.6) {
                memoryStatusEl.style.color = '#ed8936';
            } else {
                memoryStatusEl.style.color = '#718096';
            }
        }

        function removeFlow(metadataKey) {
            const metadata = groupMetadata.get(metadataKey);
            if (!metadata) return;
            
            const { type, key } = metadata;
            const flowElement = smartGroups[type].get(key);
            
            if (flowElement && flowElement.parentNode) {
                // approximate memory usage decrease
                estimatedMemoryUsage -= metadata.packetCount * 0.001;
                
                smartGroups[type].delete(key);
                flowList.removeChild(flowElement);
                groupMetadata.delete(metadataKey);
                rebuildHostMatrix();
                updateTabBadges();
            }
        }

        function cleanupOldFlows() {
            // remove oldest flows
            const flows = Array.from(groupMetadata.entries())
                .sort(([,a], [,b]) => a.lastSeen - b.lastSeen); // oldest first
            
            const memoryLimit = parseInt(getCachedElement('memoryLimit').value) || 50;
            
            while (estimatedMemoryUsage > memoryLimit * 0.7 && flows.length > 0) {
                const [oldestKey] = flows.shift();
                removeFlow(oldestKey);
            }
        }

        function rebuildHostMatrix() {
            hostIndex.clear();
            hosts = [];
            matrix = [];

            const maxSessions = parseInt(getCachedElement('maxSessions').value) || 20;

            const hostBytes = new Map();
            groupMetadata.forEach(meta => {
                const bytes = (meta.sentBytes || 0) + (meta.recvBytes || 0);
                hostBytes.set(meta.endpointA, (hostBytes.get(meta.endpointA) || 0) + bytes);
                hostBytes.set(meta.endpointB, (hostBytes.get(meta.endpointB) || 0) + bytes);
            });

            const sortedHosts = Array.from(hostBytes.entries())
                .sort(([,a], [,b]) => b - a)
                .slice(0, maxSessions)
                .map(([h]) => h);

            sortedHosts.forEach((h, idx) => {
                hostIndex.set(h, idx);
                hosts.push(h);
            });

            matrix = Array.from({length: hosts.length}, () => new Array(hosts.length).fill(0));

            groupMetadata.forEach(meta => {
                const i = hostIndex.get(meta.endpointA);
                const j = hostIndex.get(meta.endpointB);
                if (i === undefined || j === undefined) return;

                const bytes = (meta.sentBytes || 0) + (meta.recvBytes || 0);
                matrix[i][j] += bytes;
                matrix[j][i] += bytes;
            });
        }

        async function applyTsharkFilter() {
            const filterValue = document.getElementById('tsharkFilter').value.trim();
            
            try {
                const response = await fetch('/api/filter', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        tshark_filter: filterValue || null
                    })
                });
                
                if (response.ok) {
                    console.log('Filter applied:', filterValue);
                    // Clearing flows and restarting with new filter
                    flowList.innerHTML = '';
                    Object.keys(smartGroups).forEach(groupType => {
                        smartGroups[groupType].clear();
                    });
                    groupMetadata.clear();
                    packetQueue.length = 0;
                    estimatedMemoryUsage = 0;
                    rebuildHostMatrix();
                    updateMemoryDisplay();
                } else {
                    console.error('Failed to apply filter');
                }
            } catch (error) {
                console.error('Filter error:', error);
            }
        }

        function addPacketToLog(packet) {
            // localhost filtering
            const hideLocalhost = document.getElementById('hideLocalhost').checked;
            if (hideLocalhost && isLocalhostTraffic(packet)) {
                return; // skip localhost traffic
            }

            const packetDiv = document.createElement('div');
            packetDiv.className = 'packet-item';
            
            const timestamp = new Date(packet.timestamp * 1000).toLocaleTimeString();
            
            const protoLabel = packet.sub_proto ? `${packet.protocol} (${packet.sub_proto})` : packet.protocol;
            packetDiv.innerHTML = `
                <div class="packet-info">
                    <div class="packet-main">${getDisplayLabel(packet.src_ip)} â†’ ${getDisplayLabel(packet.dst_ip)}</div>
                    <div class="packet-detail">${timestamp} | ${packet.length} bytes | ${packet.info}</div>
                </div>
                <div class="packet-protocol">${protoLabel}</div>
            `;

            packetList.insertBefore(packetDiv, packetList.firstChild);

            // keep up to 100 packet logs
            while (packetList.children.length > 100) {
                packetList.removeChild(packetList.lastChild);
            }
        }

        async function updateStats() {
            try {
                const response = await fetch('/api/stats');
                const stats = await response.json();
                
                console.log('Fetched statistics:', stats);
                
                updateProtocolStats(stats.protocols);
                updateTopStats('sourceStats', stats.top_sources);
                updateTopStats('destStats', stats.top_destinations);
            } catch (error) {
                console.error('Failed to fetch statistics:', error);
            }
        }

        function updateProtocolStats(protocols) {
            const container = getCachedElement('protocolStats');
            if (!container) {
                console.error('protocolStats element not found');
                return;
            }
            
            container.innerHTML = '';
            
            console.log('Protocol stats updated:', protocols);
            
            const sorted = Object.entries(protocols)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 5);
            
            if (sorted.length === 0) {
                container.innerHTML = '<div class="stat-item"><span>No data</span><span>-</span></div>';
                return;
            }
            
            sorted.forEach(([protocol, count]) => {
                const item = document.createElement('div');
                item.className = 'stat-item';
                item.innerHTML = `<span>${protocol.toUpperCase()}</span><span>${count}</span>`;
                container.appendChild(item);
            });
        }

        function updateTopStats(containerId, data) {
            const container = getCachedElement(containerId);
            if (!container) {
                console.error(`${containerId} element not found`);
                return;
            }
            
            container.innerHTML = '';
            
            const sorted = Object.entries(data)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 5);
            
            if (sorted.length === 0) {
                container.innerHTML = '<div class="stat-item"><span>No data</span><span>-</span></div>';
                return;
            }
            
            sorted.forEach(([ip, count]) => {
                const item = document.createElement('div');
                item.className = 'stat-item';
                item.innerHTML = `<span>${ip}</span><span>${count}</span>`;
                container.appendChild(item);
            });
        }

        function updateVisualization(packet) {
            // update time series
            const sec = Math.floor(packet.timestamp);
            trafficSeries.set(sec, (trafficSeries.get(sec) || 0) + packet.length);
            totalTraffic += packet.length;

            protocolCounts.set(packet.protocol, (protocolCounts.get(packet.protocol) || 0) + 1);

            updateChordTraffic(packet.src_ip, packet.dst_ip, packet.length);
            
            // Update new visualizations
            updateTopSourcesData(packet);
            updateTopDestinationsData(packet);
            updatePacketSizeData(packet);
            updateConnectionStatesData(packet);
        }

        function updateTopSourcesData(packet) {
            const currentCount = topSourcesData.get(packet.src_ip) || 0;
            topSourcesData.set(packet.src_ip, currentCount + 1);
        }

        function updateTopDestinationsData(packet) {
            const currentCount = topDestinationsData.get(packet.dst_ip) || 0;
            topDestinationsData.set(packet.dst_ip, currentCount + 1);
        }

        function updatePacketSizeData(packet) {
            const size = packet.length;
            let category;
            if (size <= 64) category = 0;
            else if (size <= 128) category = 1;
            else if (size <= 256) category = 2;
            else if (size <= 512) category = 3;
            else if (size <= 1024) category = 4;
            else if (size <= 1500) category = 5;
            else category = 6;
            
            const currentData = packetSizeChart.data.datasets[0].data;
            currentData[category]++;
        }

        function updateConnectionStatesData(packet) {
            const protocol = packet.protocol.toUpperCase();
            let index;
            if (protocol === 'TCP') index = 0;
            else if (protocol === 'UDP') index = 1;
            else index = 2;
            
            const currentData = connectionStatesChart.data.datasets[0].data;
            currentData[index]++;
        }

        function refreshTimeChart() {
            const now = Math.floor(Date.now() / 1000);
            const windowSize = 60;
            const labels = [];
            const data = [];
            for (let i = windowSize - 1; i >= 0; i--) {
                const t = now - i;
                labels.push(new Date(t * 1000).toLocaleTimeString());
                data.push(trafficSeries.get(t) || 0);
            }
            timeChart.data.labels = labels;
            timeChart.data.datasets[0].data = data;
            timeChart.update('none');
        }

        function refreshTotalTrafficChart() {
            const now = Math.floor(Date.now() / 1000);
            const windowSize = 60;
            const labels = [];
            const data = [];
            let runningTotal = totalTraffic;
            for (let i = now; i > now - windowSize; i--) {
                labels.unshift(new Date(i * 1000).toLocaleTimeString());
                data.unshift(runningTotal);
                runningTotal -= trafficSeries.get(i) || 0;
            }
            totalChart.data.labels = labels;
            totalChart.data.datasets[0].data = data;
            totalChart.update('none');
        }

        function updateChordTraffic(src, dst, bytes) {
            let i = hostIndex.get(src);
            if (i === undefined) {
                i = hosts.length;
                hostIndex.set(src, i);
                hosts.push(src);
                matrix.forEach(row => row.push(0));
                matrix.push(new Array(hosts.length).fill(0));
            }
            let j = hostIndex.get(dst);
            if (j === undefined) {
                j = hosts.length;
                hostIndex.set(dst, j);
                hosts.push(dst);
                matrix.forEach(row => row.push(0));
                matrix.push(new Array(hosts.length).fill(0));
            }
            matrix[i][j] += bytes;
            matrix[j][i] += bytes;
        }

        function drawChordDiagram() {
            const width = 800;
            const height = 800;
            const margin = 100;
            const outerRadius = Math.min(width, height) / 2 - 40;
            const innerRadius = outerRadius - 20;

            const chord = d3.chord().padAngle(0.05)(matrix);
            const arc = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius);
            const link = d3.linkRadial().angle(d => d.angle).radius(innerRadius);
            const color = d3.scaleOrdinal(d3.schemeCategory10);

            chordSvg.attr('viewBox', [-(width / 2 + margin), -(height / 2 + margin), width + margin * 2, height + margin * 2]);
            chordSvg.selectAll('*').remove();

            const g = chordSvg.append('g');

            const groups = g.append('g')
                .selectAll('g')
                .data(chord.groups)
                .join('g');

            groups.append('path')
                .attr('fill', d => color(d.index))
                .attr('d', arc);

            groups.append('text')
                .attr('dy', -3)
                .attr('fill', '#fff')
                .attr('transform', d => {
                    const angle = (d.startAngle + d.endAngle) / 2;
                    const rotate = angle * 180 / Math.PI - 90;
                    const flip = angle > Math.PI ? ' rotate(180)' : '';
                    const translate = outerRadius + 10;
                    return `rotate(${rotate}) translate(${translate})${flip}`;
                })
                .attr('text-anchor', d => ((d.startAngle + d.endAngle) / 2) > Math.PI ? 'end' : 'start')
                .text(d => hosts[d.index]);

            g.append('g')
                .attr('fill', 'none')
                .selectAll('path')
                .data(chord)
                .join('path')
                .attr('stroke', '#888')
                .attr('stroke-width', 1.5)
                .attr('d', d => link({
                    source: { angle: (d.source.startAngle + d.source.endAngle) / 2, radius: innerRadius },
                    target: { angle: (d.target.startAngle + d.target.endAngle) / 2, radius: innerRadius }
                }));
        }

        function refreshProtocolChart() {
            const labels = Array.from(protocolCounts.keys());
            const data = labels.map(l => protocolCounts.get(l));
            protocolChart.data.labels = labels;
            protocolChart.data.datasets[0].data = data;
            protocolChart.update('none');
        }

        function refreshTopSourcesChart() {
            const sorted = Array.from(topSourcesData.entries())
                .sort(([,a], [,b]) => b - a)
                .slice(0, 10);
            
            const labels = sorted.map(([ip]) => getDisplayLabel(ip));
            const data = sorted.map(([,count]) => count);
            
            topSourcesChart.data.labels = labels;
            topSourcesChart.data.datasets[0].data = data;
            topSourcesChart.update('none');
        }

        function refreshTopDestinationsChart() {
            const sorted = Array.from(topDestinationsData.entries())
                .sort(([,a], [,b]) => b - a)
                .slice(0, 10);
            
            const labels = sorted.map(([ip]) => getDisplayLabel(ip));
            const data = sorted.map(([,count]) => count);
            
            topDestinationsChart.data.labels = labels;
            topDestinationsChart.data.datasets[0].data = data;
            topDestinationsChart.update('none');
        }

        function refreshPacketSizeChart() {
            packetSizeChart.update('none');
        }

        function refreshConnectionStatesChart() {
            connectionStatesChart.update('none');
        }

        setInterval(() => {
            refreshTimeChart();
            refreshTotalTrafficChart();
            drawChordDiagram();
            refreshProtocolChart();
            refreshTopSourcesChart();
            refreshTopDestinationsChart();
            refreshPacketSizeChart();
            refreshConnectionStatesChart();
        }, 1000);

        startBtn.addEventListener('click', function() {
            if (!isRunning) {
                connectWebSocket();
            }
        });

        stopBtn.addEventListener('click', function() {
            if (ws && isRunning) {
                ws.close();
            }
        });

        clearBtn.addEventListener('click', function() {
            flowList.innerHTML = '';
            // clear all smart groups
            Object.keys(smartGroups).forEach(groupType => {
                smartGroups[groupType].clear();
            });
            groupMetadata.clear();
            packetQueue.length = 0; // clear queue too
            packetCount = 0;
            estimatedMemoryUsage = 0;
            totalPacketsEl.textContent = '0';
            protocolCounts.clear();
            
            // Clear new visualization data
            topSourcesData.clear();
            topDestinationsData.clear();
            packetSizeChart.data.datasets[0].data = [0, 0, 0, 0, 0, 0, 0];
            connectionStatesChart.data.datasets[0].data = [0, 0, 0];
            
            rebuildHostMatrix();
            updateMemoryDisplay();
            updateTabBadges();
        });

        // sort feature event listener
        getCachedElement('sortSessions').addEventListener('change', function() {
            sortFlows(); // sort immediately
        });

        // reset flows when LAN/WAN grouping changes
        groupLanWanCheckbox.addEventListener('change', function() {
            clearBtn.click();
        });

        // filter apply button listener
        applyFilterBtn.addEventListener('click', applyTsharkFilter);

        // apply filter on Enter key
        document.getElementById('tsharkFilter').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                applyTsharkFilter();
            }
        });

        // update statistics periodically
        setInterval(updateStats, 5000); // back to 5 seconds
        
        // regular memory display update
        setInterval(updateMemoryDisplay, 2000);
        
        // fetch initial statistics
        updateStats();

        // Initialize enhanced tab system
        setupSearchFilters();
        restoreTabState();
        updateTabBadges();

    
-->
</body>
</html>
